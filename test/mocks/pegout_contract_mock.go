// Code generated by mockery v2.53.0. DO NOT EDIT.

package mocks

import (
	context "context"

	blockchain "github.com/rsksmart/liquidity-provider-server/internal/entities/blockchain"

	mock "github.com/stretchr/testify/mock"

	quote "github.com/rsksmart/liquidity-provider-server/internal/entities/quote"
)

// PegoutContractMock is an autogenerated mock type for the PegoutContract type
type PegoutContractMock struct {
	mock.Mock
}

type PegoutContractMock_Expecter struct {
	mock *mock.Mock
}

func (_m *PegoutContractMock) EXPECT() *PegoutContractMock_Expecter {
	return &PegoutContractMock_Expecter{mock: &_m.Mock}
}

// DaoFeePercentage provides a mock function with no fields
func (_m *PegoutContractMock) DaoFeePercentage() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DaoFeePercentage")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractMock_DaoFeePercentage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DaoFeePercentage'
type PegoutContractMock_DaoFeePercentage_Call struct {
	*mock.Call
}

// DaoFeePercentage is a helper method to define mock.On call
func (_e *PegoutContractMock_Expecter) DaoFeePercentage() *PegoutContractMock_DaoFeePercentage_Call {
	return &PegoutContractMock_DaoFeePercentage_Call{Call: _e.mock.On("DaoFeePercentage")}
}

func (_c *PegoutContractMock_DaoFeePercentage_Call) Run(run func()) *PegoutContractMock_DaoFeePercentage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PegoutContractMock_DaoFeePercentage_Call) Return(_a0 uint64, _a1 error) *PegoutContractMock_DaoFeePercentage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractMock_DaoFeePercentage_Call) RunAndReturn(run func() (uint64, error)) *PegoutContractMock_DaoFeePercentage_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddress provides a mock function with no fields
func (_m *PegoutContractMock) GetAddress() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAddress")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// PegoutContractMock_GetAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddress'
type PegoutContractMock_GetAddress_Call struct {
	*mock.Call
}

// GetAddress is a helper method to define mock.On call
func (_e *PegoutContractMock_Expecter) GetAddress() *PegoutContractMock_GetAddress_Call {
	return &PegoutContractMock_GetAddress_Call{Call: _e.mock.On("GetAddress")}
}

func (_c *PegoutContractMock_GetAddress_Call) Run(run func()) *PegoutContractMock_GetAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PegoutContractMock_GetAddress_Call) Return(_a0 string) *PegoutContractMock_GetAddress_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PegoutContractMock_GetAddress_Call) RunAndReturn(run func() string) *PegoutContractMock_GetAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetDepositEvents provides a mock function with given fields: ctx, fromBlock, toBlock
func (_m *PegoutContractMock) GetDepositEvents(ctx context.Context, fromBlock uint64, toBlock *uint64) ([]quote.PegoutDeposit, error) {
	ret := _m.Called(ctx, fromBlock, toBlock)

	if len(ret) == 0 {
		panic("no return value specified for GetDepositEvents")
	}

	var r0 []quote.PegoutDeposit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, *uint64) ([]quote.PegoutDeposit, error)); ok {
		return rf(ctx, fromBlock, toBlock)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, *uint64) []quote.PegoutDeposit); ok {
		r0 = rf(ctx, fromBlock, toBlock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]quote.PegoutDeposit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, *uint64) error); ok {
		r1 = rf(ctx, fromBlock, toBlock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractMock_GetDepositEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDepositEvents'
type PegoutContractMock_GetDepositEvents_Call struct {
	*mock.Call
}

// GetDepositEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - fromBlock uint64
//   - toBlock *uint64
func (_e *PegoutContractMock_Expecter) GetDepositEvents(ctx interface{}, fromBlock interface{}, toBlock interface{}) *PegoutContractMock_GetDepositEvents_Call {
	return &PegoutContractMock_GetDepositEvents_Call{Call: _e.mock.On("GetDepositEvents", ctx, fromBlock, toBlock)}
}

func (_c *PegoutContractMock_GetDepositEvents_Call) Run(run func(ctx context.Context, fromBlock uint64, toBlock *uint64)) *PegoutContractMock_GetDepositEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(*uint64))
	})
	return _c
}

func (_c *PegoutContractMock_GetDepositEvents_Call) Return(_a0 []quote.PegoutDeposit, _a1 error) *PegoutContractMock_GetDepositEvents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractMock_GetDepositEvents_Call) RunAndReturn(run func(context.Context, uint64, *uint64) ([]quote.PegoutDeposit, error)) *PegoutContractMock_GetDepositEvents_Call {
	_c.Call.Return(run)
	return _c
}

// HashPegoutQuote provides a mock function with given fields: pegoutQuote
func (_m *PegoutContractMock) HashPegoutQuote(pegoutQuote quote.PegoutQuote) (string, error) {
	ret := _m.Called(pegoutQuote)

	if len(ret) == 0 {
		panic("no return value specified for HashPegoutQuote")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(quote.PegoutQuote) (string, error)); ok {
		return rf(pegoutQuote)
	}
	if rf, ok := ret.Get(0).(func(quote.PegoutQuote) string); ok {
		r0 = rf(pegoutQuote)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(quote.PegoutQuote) error); ok {
		r1 = rf(pegoutQuote)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractMock_HashPegoutQuote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashPegoutQuote'
type PegoutContractMock_HashPegoutQuote_Call struct {
	*mock.Call
}

// HashPegoutQuote is a helper method to define mock.On call
//   - pegoutQuote quote.PegoutQuote
func (_e *PegoutContractMock_Expecter) HashPegoutQuote(pegoutQuote interface{}) *PegoutContractMock_HashPegoutQuote_Call {
	return &PegoutContractMock_HashPegoutQuote_Call{Call: _e.mock.On("HashPegoutQuote", pegoutQuote)}
}

func (_c *PegoutContractMock_HashPegoutQuote_Call) Run(run func(pegoutQuote quote.PegoutQuote)) *PegoutContractMock_HashPegoutQuote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(quote.PegoutQuote))
	})
	return _c
}

func (_c *PegoutContractMock_HashPegoutQuote_Call) Return(_a0 string, _a1 error) *PegoutContractMock_HashPegoutQuote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractMock_HashPegoutQuote_Call) RunAndReturn(run func(quote.PegoutQuote) (string, error)) *PegoutContractMock_HashPegoutQuote_Call {
	_c.Call.Return(run)
	return _c
}

// IsPegOutQuoteCompleted provides a mock function with given fields: quoteHash
func (_m *PegoutContractMock) IsPegOutQuoteCompleted(quoteHash string) (bool, error) {
	ret := _m.Called(quoteHash)

	if len(ret) == 0 {
		panic("no return value specified for IsPegOutQuoteCompleted")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(quoteHash)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(quoteHash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(quoteHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractMock_IsPegOutQuoteCompleted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsPegOutQuoteCompleted'
type PegoutContractMock_IsPegOutQuoteCompleted_Call struct {
	*mock.Call
}

// IsPegOutQuoteCompleted is a helper method to define mock.On call
//   - quoteHash string
func (_e *PegoutContractMock_Expecter) IsPegOutQuoteCompleted(quoteHash interface{}) *PegoutContractMock_IsPegOutQuoteCompleted_Call {
	return &PegoutContractMock_IsPegOutQuoteCompleted_Call{Call: _e.mock.On("IsPegOutQuoteCompleted", quoteHash)}
}

func (_c *PegoutContractMock_IsPegOutQuoteCompleted_Call) Run(run func(quoteHash string)) *PegoutContractMock_IsPegOutQuoteCompleted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *PegoutContractMock_IsPegOutQuoteCompleted_Call) Return(_a0 bool, _a1 error) *PegoutContractMock_IsPegOutQuoteCompleted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractMock_IsPegOutQuoteCompleted_Call) RunAndReturn(run func(string) (bool, error)) *PegoutContractMock_IsPegOutQuoteCompleted_Call {
	_c.Call.Return(run)
	return _c
}

// RefundPegout provides a mock function with given fields: txConfig, params
func (_m *PegoutContractMock) RefundPegout(txConfig blockchain.TransactionConfig, params blockchain.RefundPegoutParams) (string, error) {
	ret := _m.Called(txConfig, params)

	if len(ret) == 0 {
		panic("no return value specified for RefundPegout")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(blockchain.TransactionConfig, blockchain.RefundPegoutParams) (string, error)); ok {
		return rf(txConfig, params)
	}
	if rf, ok := ret.Get(0).(func(blockchain.TransactionConfig, blockchain.RefundPegoutParams) string); ok {
		r0 = rf(txConfig, params)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(blockchain.TransactionConfig, blockchain.RefundPegoutParams) error); ok {
		r1 = rf(txConfig, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractMock_RefundPegout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefundPegout'
type PegoutContractMock_RefundPegout_Call struct {
	*mock.Call
}

// RefundPegout is a helper method to define mock.On call
//   - txConfig blockchain.TransactionConfig
//   - params blockchain.RefundPegoutParams
func (_e *PegoutContractMock_Expecter) RefundPegout(txConfig interface{}, params interface{}) *PegoutContractMock_RefundPegout_Call {
	return &PegoutContractMock_RefundPegout_Call{Call: _e.mock.On("RefundPegout", txConfig, params)}
}

func (_c *PegoutContractMock_RefundPegout_Call) Run(run func(txConfig blockchain.TransactionConfig, params blockchain.RefundPegoutParams)) *PegoutContractMock_RefundPegout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(blockchain.TransactionConfig), args[1].(blockchain.RefundPegoutParams))
	})
	return _c
}

func (_c *PegoutContractMock_RefundPegout_Call) Return(_a0 string, _a1 error) *PegoutContractMock_RefundPegout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractMock_RefundPegout_Call) RunAndReturn(run func(blockchain.TransactionConfig, blockchain.RefundPegoutParams) (string, error)) *PegoutContractMock_RefundPegout_Call {
	_c.Call.Return(run)
	return _c
}

// RefundUserPegOut provides a mock function with given fields: quoteHash
func (_m *PegoutContractMock) RefundUserPegOut(quoteHash string) (string, error) {
	ret := _m.Called(quoteHash)

	if len(ret) == 0 {
		panic("no return value specified for RefundUserPegOut")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(quoteHash)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(quoteHash)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(quoteHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractMock_RefundUserPegOut_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefundUserPegOut'
type PegoutContractMock_RefundUserPegOut_Call struct {
	*mock.Call
}

// RefundUserPegOut is a helper method to define mock.On call
//   - quoteHash string
func (_e *PegoutContractMock_Expecter) RefundUserPegOut(quoteHash interface{}) *PegoutContractMock_RefundUserPegOut_Call {
	return &PegoutContractMock_RefundUserPegOut_Call{Call: _e.mock.On("RefundUserPegOut", quoteHash)}
}

func (_c *PegoutContractMock_RefundUserPegOut_Call) Run(run func(quoteHash string)) *PegoutContractMock_RefundUserPegOut_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *PegoutContractMock_RefundUserPegOut_Call) Return(_a0 string, _a1 error) *PegoutContractMock_RefundUserPegOut_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractMock_RefundUserPegOut_Call) RunAndReturn(run func(string) (string, error)) *PegoutContractMock_RefundUserPegOut_Call {
	_c.Call.Return(run)
	return _c
}

// ValidatePegout provides a mock function with given fields: quoteHash, btcTx
func (_m *PegoutContractMock) ValidatePegout(quoteHash string, btcTx []byte) error {
	ret := _m.Called(quoteHash, btcTx)

	if len(ret) == 0 {
		panic("no return value specified for ValidatePegout")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []byte) error); ok {
		r0 = rf(quoteHash, btcTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PegoutContractMock_ValidatePegout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidatePegout'
type PegoutContractMock_ValidatePegout_Call struct {
	*mock.Call
}

// ValidatePegout is a helper method to define mock.On call
//   - quoteHash string
//   - btcTx []byte
func (_e *PegoutContractMock_Expecter) ValidatePegout(quoteHash interface{}, btcTx interface{}) *PegoutContractMock_ValidatePegout_Call {
	return &PegoutContractMock_ValidatePegout_Call{Call: _e.mock.On("ValidatePegout", quoteHash, btcTx)}
}

func (_c *PegoutContractMock_ValidatePegout_Call) Run(run func(quoteHash string, btcTx []byte)) *PegoutContractMock_ValidatePegout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]byte))
	})
	return _c
}

func (_c *PegoutContractMock_ValidatePegout_Call) Return(_a0 error) *PegoutContractMock_ValidatePegout_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PegoutContractMock_ValidatePegout_Call) RunAndReturn(run func(string, []byte) error) *PegoutContractMock_ValidatePegout_Call {
	_c.Call.Return(run)
	return _c
}

// NewPegoutContractMock creates a new instance of PegoutContractMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPegoutContractMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *PegoutContractMock {
	mock := &PegoutContractMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
