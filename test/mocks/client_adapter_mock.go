// Code generated by mockery v2.48.0. DO NOT EDIT.

package mocks

import (
	btcjson "github.com/btcsuite/btcd/btcjson"
	btcclient "github.com/rsksmart/liquidity-provider-server/internal/adapters/dataproviders/bitcoin/btcclient"

	btcutil "github.com/btcsuite/btcd/btcutil"

	chainhash "github.com/btcsuite/btcd/chaincfg/chainhash"

	mock "github.com/stretchr/testify/mock"

	rpcclient "github.com/btcsuite/btcd/rpcclient"

	wire "github.com/btcsuite/btcd/wire"
)

// ClientAdapterMock is an autogenerated mock type for the ClientAdapter type
type ClientAdapterMock struct {
	mock.Mock
}

type ClientAdapterMock_Expecter struct {
	mock *mock.Mock
}

func (_m *ClientAdapterMock) EXPECT() *ClientAdapterMock_Expecter {
	return &ClientAdapterMock_Expecter{mock: &_m.Mock}
}

// CreateRawTransaction provides a mock function with given fields: inputs, amounts, lockTime
func (_m *ClientAdapterMock) CreateRawTransaction(inputs []btcjson.TransactionInput, amounts map[btcutil.Address]btcutil.Amount, lockTime *int64) (*wire.MsgTx, error) {
	ret := _m.Called(inputs, amounts, lockTime)

	if len(ret) == 0 {
		panic("no return value specified for CreateRawTransaction")
	}

	var r0 *wire.MsgTx
	var r1 error
	if rf, ok := ret.Get(0).(func([]btcjson.TransactionInput, map[btcutil.Address]btcutil.Amount, *int64) (*wire.MsgTx, error)); ok {
		return rf(inputs, amounts, lockTime)
	}
	if rf, ok := ret.Get(0).(func([]btcjson.TransactionInput, map[btcutil.Address]btcutil.Amount, *int64) *wire.MsgTx); ok {
		r0 = rf(inputs, amounts, lockTime)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wire.MsgTx)
		}
	}

	if rf, ok := ret.Get(1).(func([]btcjson.TransactionInput, map[btcutil.Address]btcutil.Amount, *int64) error); ok {
		r1 = rf(inputs, amounts, lockTime)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_CreateRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRawTransaction'
type ClientAdapterMock_CreateRawTransaction_Call struct {
	*mock.Call
}

// CreateRawTransaction is a helper method to define mock.On call
//   - inputs []btcjson.TransactionInput
//   - amounts map[btcutil.Address]btcutil.Amount
//   - lockTime *int64
func (_e *ClientAdapterMock_Expecter) CreateRawTransaction(inputs interface{}, amounts interface{}, lockTime interface{}) *ClientAdapterMock_CreateRawTransaction_Call {
	return &ClientAdapterMock_CreateRawTransaction_Call{Call: _e.mock.On("CreateRawTransaction", inputs, amounts, lockTime)}
}

func (_c *ClientAdapterMock_CreateRawTransaction_Call) Run(run func(inputs []btcjson.TransactionInput, amounts map[btcutil.Address]btcutil.Amount, lockTime *int64)) *ClientAdapterMock_CreateRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]btcjson.TransactionInput), args[1].(map[btcutil.Address]btcutil.Amount), args[2].(*int64))
	})
	return _c
}

func (_c *ClientAdapterMock_CreateRawTransaction_Call) Return(_a0 *wire.MsgTx, _a1 error) *ClientAdapterMock_CreateRawTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_CreateRawTransaction_Call) RunAndReturn(run func([]btcjson.TransactionInput, map[btcutil.Address]btcutil.Amount, *int64) (*wire.MsgTx, error)) *ClientAdapterMock_CreateRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// CreateReadonlyWallet provides a mock function with given fields: bodyParams
func (_m *ClientAdapterMock) CreateReadonlyWallet(bodyParams btcclient.ReadonlyWalletRequest) error {
	ret := _m.Called(bodyParams)

	if len(ret) == 0 {
		panic("no return value specified for CreateReadonlyWallet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(btcclient.ReadonlyWalletRequest) error); ok {
		r0 = rf(bodyParams)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientAdapterMock_CreateReadonlyWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateReadonlyWallet'
type ClientAdapterMock_CreateReadonlyWallet_Call struct {
	*mock.Call
}

// CreateReadonlyWallet is a helper method to define mock.On call
//   - bodyParams btcclient.ReadonlyWalletRequest
func (_e *ClientAdapterMock_Expecter) CreateReadonlyWallet(bodyParams interface{}) *ClientAdapterMock_CreateReadonlyWallet_Call {
	return &ClientAdapterMock_CreateReadonlyWallet_Call{Call: _e.mock.On("CreateReadonlyWallet", bodyParams)}
}

func (_c *ClientAdapterMock_CreateReadonlyWallet_Call) Run(run func(bodyParams btcclient.ReadonlyWalletRequest)) *ClientAdapterMock_CreateReadonlyWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(btcclient.ReadonlyWalletRequest))
	})
	return _c
}

func (_c *ClientAdapterMock_CreateReadonlyWallet_Call) Return(_a0 error) *ClientAdapterMock_CreateReadonlyWallet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientAdapterMock_CreateReadonlyWallet_Call) RunAndReturn(run func(btcclient.ReadonlyWalletRequest) error) *ClientAdapterMock_CreateReadonlyWallet_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWallet provides a mock function with given fields: name, opts
func (_m *ClientAdapterMock) CreateWallet(name string, opts ...rpcclient.CreateWalletOpt) (*btcjson.CreateWalletResult, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWallet")
	}

	var r0 *btcjson.CreateWalletResult
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...rpcclient.CreateWalletOpt) (*btcjson.CreateWalletResult, error)); ok {
		return rf(name, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...rpcclient.CreateWalletOpt) *btcjson.CreateWalletResult); ok {
		r0 = rf(name, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.CreateWalletResult)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...rpcclient.CreateWalletOpt) error); ok {
		r1 = rf(name, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_CreateWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWallet'
type ClientAdapterMock_CreateWallet_Call struct {
	*mock.Call
}

// CreateWallet is a helper method to define mock.On call
//   - name string
//   - opts ...rpcclient.CreateWalletOpt
func (_e *ClientAdapterMock_Expecter) CreateWallet(name interface{}, opts ...interface{}) *ClientAdapterMock_CreateWallet_Call {
	return &ClientAdapterMock_CreateWallet_Call{Call: _e.mock.On("CreateWallet",
		append([]interface{}{name}, opts...)...)}
}

func (_c *ClientAdapterMock_CreateWallet_Call) Run(run func(name string, opts ...rpcclient.CreateWalletOpt)) *ClientAdapterMock_CreateWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]rpcclient.CreateWalletOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(rpcclient.CreateWalletOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *ClientAdapterMock_CreateWallet_Call) Return(_a0 *btcjson.CreateWalletResult, _a1 error) *ClientAdapterMock_CreateWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_CreateWallet_Call) RunAndReturn(run func(string, ...rpcclient.CreateWalletOpt) (*btcjson.CreateWalletResult, error)) *ClientAdapterMock_CreateWallet_Call {
	_c.Call.Return(run)
	return _c
}

// Disconnect provides a mock function with given fields:
func (_m *ClientAdapterMock) Disconnect() {
	_m.Called()
}

// ClientAdapterMock_Disconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Disconnect'
type ClientAdapterMock_Disconnect_Call struct {
	*mock.Call
}

// Disconnect is a helper method to define mock.On call
func (_e *ClientAdapterMock_Expecter) Disconnect() *ClientAdapterMock_Disconnect_Call {
	return &ClientAdapterMock_Disconnect_Call{Call: _e.mock.On("Disconnect")}
}

func (_c *ClientAdapterMock_Disconnect_Call) Run(run func()) *ClientAdapterMock_Disconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientAdapterMock_Disconnect_Call) Return() *ClientAdapterMock_Disconnect_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClientAdapterMock_Disconnect_Call) RunAndReturn(run func()) *ClientAdapterMock_Disconnect_Call {
	_c.Call.Return(run)
	return _c
}

// EstimateSmartFee provides a mock function with given fields: confTarget, mode
func (_m *ClientAdapterMock) EstimateSmartFee(confTarget int64, mode *btcjson.EstimateSmartFeeMode) (*btcjson.EstimateSmartFeeResult, error) {
	ret := _m.Called(confTarget, mode)

	if len(ret) == 0 {
		panic("no return value specified for EstimateSmartFee")
	}

	var r0 *btcjson.EstimateSmartFeeResult
	var r1 error
	if rf, ok := ret.Get(0).(func(int64, *btcjson.EstimateSmartFeeMode) (*btcjson.EstimateSmartFeeResult, error)); ok {
		return rf(confTarget, mode)
	}
	if rf, ok := ret.Get(0).(func(int64, *btcjson.EstimateSmartFeeMode) *btcjson.EstimateSmartFeeResult); ok {
		r0 = rf(confTarget, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.EstimateSmartFeeResult)
		}
	}

	if rf, ok := ret.Get(1).(func(int64, *btcjson.EstimateSmartFeeMode) error); ok {
		r1 = rf(confTarget, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_EstimateSmartFee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EstimateSmartFee'
type ClientAdapterMock_EstimateSmartFee_Call struct {
	*mock.Call
}

// EstimateSmartFee is a helper method to define mock.On call
//   - confTarget int64
//   - mode *btcjson.EstimateSmartFeeMode
func (_e *ClientAdapterMock_Expecter) EstimateSmartFee(confTarget interface{}, mode interface{}) *ClientAdapterMock_EstimateSmartFee_Call {
	return &ClientAdapterMock_EstimateSmartFee_Call{Call: _e.mock.On("EstimateSmartFee", confTarget, mode)}
}

func (_c *ClientAdapterMock_EstimateSmartFee_Call) Run(run func(confTarget int64, mode *btcjson.EstimateSmartFeeMode)) *ClientAdapterMock_EstimateSmartFee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(*btcjson.EstimateSmartFeeMode))
	})
	return _c
}

func (_c *ClientAdapterMock_EstimateSmartFee_Call) Return(_a0 *btcjson.EstimateSmartFeeResult, _a1 error) *ClientAdapterMock_EstimateSmartFee_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_EstimateSmartFee_Call) RunAndReturn(run func(int64, *btcjson.EstimateSmartFeeMode) (*btcjson.EstimateSmartFeeResult, error)) *ClientAdapterMock_EstimateSmartFee_Call {
	_c.Call.Return(run)
	return _c
}

// FundRawTransaction provides a mock function with given fields: tx, opts, isWitness
func (_m *ClientAdapterMock) FundRawTransaction(tx *wire.MsgTx, opts btcjson.FundRawTransactionOpts, isWitness *bool) (*btcjson.FundRawTransactionResult, error) {
	ret := _m.Called(tx, opts, isWitness)

	if len(ret) == 0 {
		panic("no return value specified for FundRawTransaction")
	}

	var r0 *btcjson.FundRawTransactionResult
	var r1 error
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, btcjson.FundRawTransactionOpts, *bool) (*btcjson.FundRawTransactionResult, error)); ok {
		return rf(tx, opts, isWitness)
	}
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, btcjson.FundRawTransactionOpts, *bool) *btcjson.FundRawTransactionResult); ok {
		r0 = rf(tx, opts, isWitness)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.FundRawTransactionResult)
		}
	}

	if rf, ok := ret.Get(1).(func(*wire.MsgTx, btcjson.FundRawTransactionOpts, *bool) error); ok {
		r1 = rf(tx, opts, isWitness)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_FundRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FundRawTransaction'
type ClientAdapterMock_FundRawTransaction_Call struct {
	*mock.Call
}

// FundRawTransaction is a helper method to define mock.On call
//   - tx *wire.MsgTx
//   - opts btcjson.FundRawTransactionOpts
//   - isWitness *bool
func (_e *ClientAdapterMock_Expecter) FundRawTransaction(tx interface{}, opts interface{}, isWitness interface{}) *ClientAdapterMock_FundRawTransaction_Call {
	return &ClientAdapterMock_FundRawTransaction_Call{Call: _e.mock.On("FundRawTransaction", tx, opts, isWitness)}
}

func (_c *ClientAdapterMock_FundRawTransaction_Call) Run(run func(tx *wire.MsgTx, opts btcjson.FundRawTransactionOpts, isWitness *bool)) *ClientAdapterMock_FundRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*wire.MsgTx), args[1].(btcjson.FundRawTransactionOpts), args[2].(*bool))
	})
	return _c
}

func (_c *ClientAdapterMock_FundRawTransaction_Call) Return(_a0 *btcjson.FundRawTransactionResult, _a1 error) *ClientAdapterMock_FundRawTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_FundRawTransaction_Call) RunAndReturn(run func(*wire.MsgTx, btcjson.FundRawTransactionOpts, *bool) (*btcjson.FundRawTransactionResult, error)) *ClientAdapterMock_FundRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddressInfo provides a mock function with given fields: address
func (_m *ClientAdapterMock) GetAddressInfo(address string) (*btcjson.GetAddressInfoResult, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAddressInfo")
	}

	var r0 *btcjson.GetAddressInfoResult
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*btcjson.GetAddressInfoResult, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) *btcjson.GetAddressInfoResult); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetAddressInfoResult)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_GetAddressInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddressInfo'
type ClientAdapterMock_GetAddressInfo_Call struct {
	*mock.Call
}

// GetAddressInfo is a helper method to define mock.On call
//   - address string
func (_e *ClientAdapterMock_Expecter) GetAddressInfo(address interface{}) *ClientAdapterMock_GetAddressInfo_Call {
	return &ClientAdapterMock_GetAddressInfo_Call{Call: _e.mock.On("GetAddressInfo", address)}
}

func (_c *ClientAdapterMock_GetAddressInfo_Call) Run(run func(address string)) *ClientAdapterMock_GetAddressInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ClientAdapterMock_GetAddressInfo_Call) Return(_a0 *btcjson.GetAddressInfoResult, _a1 error) *ClientAdapterMock_GetAddressInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_GetAddressInfo_Call) RunAndReturn(run func(string) (*btcjson.GetAddressInfoResult, error)) *ClientAdapterMock_GetAddressInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlock provides a mock function with given fields: blockHash
func (_m *ClientAdapterMock) GetBlock(blockHash *chainhash.Hash) (*wire.MsgBlock, error) {
	ret := _m.Called(blockHash)

	if len(ret) == 0 {
		panic("no return value specified for GetBlock")
	}

	var r0 *wire.MsgBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*wire.MsgBlock, error)); ok {
		return rf(blockHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *wire.MsgBlock); ok {
		r0 = rf(blockHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wire.MsgBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(blockHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_GetBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlock'
type ClientAdapterMock_GetBlock_Call struct {
	*mock.Call
}

// GetBlock is a helper method to define mock.On call
//   - blockHash *chainhash.Hash
func (_e *ClientAdapterMock_Expecter) GetBlock(blockHash interface{}) *ClientAdapterMock_GetBlock_Call {
	return &ClientAdapterMock_GetBlock_Call{Call: _e.mock.On("GetBlock", blockHash)}
}

func (_c *ClientAdapterMock_GetBlock_Call) Run(run func(blockHash *chainhash.Hash)) *ClientAdapterMock_GetBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *ClientAdapterMock_GetBlock_Call) Return(_a0 *wire.MsgBlock, _a1 error) *ClientAdapterMock_GetBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_GetBlock_Call) RunAndReturn(run func(*chainhash.Hash) (*wire.MsgBlock, error)) *ClientAdapterMock_GetBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockChainInfo provides a mock function with given fields:
func (_m *ClientAdapterMock) GetBlockChainInfo() (*btcjson.GetBlockChainInfoResult, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBlockChainInfo")
	}

	var r0 *btcjson.GetBlockChainInfoResult
	var r1 error
	if rf, ok := ret.Get(0).(func() (*btcjson.GetBlockChainInfoResult, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *btcjson.GetBlockChainInfoResult); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetBlockChainInfoResult)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_GetBlockChainInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockChainInfo'
type ClientAdapterMock_GetBlockChainInfo_Call struct {
	*mock.Call
}

// GetBlockChainInfo is a helper method to define mock.On call
func (_e *ClientAdapterMock_Expecter) GetBlockChainInfo() *ClientAdapterMock_GetBlockChainInfo_Call {
	return &ClientAdapterMock_GetBlockChainInfo_Call{Call: _e.mock.On("GetBlockChainInfo")}
}

func (_c *ClientAdapterMock_GetBlockChainInfo_Call) Run(run func()) *ClientAdapterMock_GetBlockChainInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientAdapterMock_GetBlockChainInfo_Call) Return(_a0 *btcjson.GetBlockChainInfoResult, _a1 error) *ClientAdapterMock_GetBlockChainInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_GetBlockChainInfo_Call) RunAndReturn(run func() (*btcjson.GetBlockChainInfoResult, error)) *ClientAdapterMock_GetBlockChainInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockVerbose provides a mock function with given fields: blockHash
func (_m *ClientAdapterMock) GetBlockVerbose(blockHash *chainhash.Hash) (*btcjson.GetBlockVerboseResult, error) {
	ret := _m.Called(blockHash)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockVerbose")
	}

	var r0 *btcjson.GetBlockVerboseResult
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*btcjson.GetBlockVerboseResult, error)); ok {
		return rf(blockHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *btcjson.GetBlockVerboseResult); ok {
		r0 = rf(blockHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetBlockVerboseResult)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(blockHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_GetBlockVerbose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockVerbose'
type ClientAdapterMock_GetBlockVerbose_Call struct {
	*mock.Call
}

// GetBlockVerbose is a helper method to define mock.On call
//   - blockHash *chainhash.Hash
func (_e *ClientAdapterMock_Expecter) GetBlockVerbose(blockHash interface{}) *ClientAdapterMock_GetBlockVerbose_Call {
	return &ClientAdapterMock_GetBlockVerbose_Call{Call: _e.mock.On("GetBlockVerbose", blockHash)}
}

func (_c *ClientAdapterMock_GetBlockVerbose_Call) Run(run func(blockHash *chainhash.Hash)) *ClientAdapterMock_GetBlockVerbose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *ClientAdapterMock_GetBlockVerbose_Call) Return(_a0 *btcjson.GetBlockVerboseResult, _a1 error) *ClientAdapterMock_GetBlockVerbose_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_GetBlockVerbose_Call) RunAndReturn(run func(*chainhash.Hash) (*btcjson.GetBlockVerboseResult, error)) *ClientAdapterMock_GetBlockVerbose_Call {
	_c.Call.Return(run)
	return _c
}

// GetRawTransaction provides a mock function with given fields: txHash
func (_m *ClientAdapterMock) GetRawTransaction(txHash *chainhash.Hash) (*btcutil.Tx, error) {
	ret := _m.Called(txHash)

	if len(ret) == 0 {
		panic("no return value specified for GetRawTransaction")
	}

	var r0 *btcutil.Tx
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*btcutil.Tx, error)); ok {
		return rf(txHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *btcutil.Tx); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcutil.Tx)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_GetRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRawTransaction'
type ClientAdapterMock_GetRawTransaction_Call struct {
	*mock.Call
}

// GetRawTransaction is a helper method to define mock.On call
//   - txHash *chainhash.Hash
func (_e *ClientAdapterMock_Expecter) GetRawTransaction(txHash interface{}) *ClientAdapterMock_GetRawTransaction_Call {
	return &ClientAdapterMock_GetRawTransaction_Call{Call: _e.mock.On("GetRawTransaction", txHash)}
}

func (_c *ClientAdapterMock_GetRawTransaction_Call) Run(run func(txHash *chainhash.Hash)) *ClientAdapterMock_GetRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *ClientAdapterMock_GetRawTransaction_Call) Return(_a0 *btcutil.Tx, _a1 error) *ClientAdapterMock_GetRawTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_GetRawTransaction_Call) RunAndReturn(run func(*chainhash.Hash) (*btcutil.Tx, error)) *ClientAdapterMock_GetRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// GetRawTransactionVerbose provides a mock function with given fields: txHash
func (_m *ClientAdapterMock) GetRawTransactionVerbose(txHash *chainhash.Hash) (*btcjson.TxRawResult, error) {
	ret := _m.Called(txHash)

	if len(ret) == 0 {
		panic("no return value specified for GetRawTransactionVerbose")
	}

	var r0 *btcjson.TxRawResult
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*btcjson.TxRawResult, error)); ok {
		return rf(txHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *btcjson.TxRawResult); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.TxRawResult)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_GetRawTransactionVerbose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRawTransactionVerbose'
type ClientAdapterMock_GetRawTransactionVerbose_Call struct {
	*mock.Call
}

// GetRawTransactionVerbose is a helper method to define mock.On call
//   - txHash *chainhash.Hash
func (_e *ClientAdapterMock_Expecter) GetRawTransactionVerbose(txHash interface{}) *ClientAdapterMock_GetRawTransactionVerbose_Call {
	return &ClientAdapterMock_GetRawTransactionVerbose_Call{Call: _e.mock.On("GetRawTransactionVerbose", txHash)}
}

func (_c *ClientAdapterMock_GetRawTransactionVerbose_Call) Run(run func(txHash *chainhash.Hash)) *ClientAdapterMock_GetRawTransactionVerbose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *ClientAdapterMock_GetRawTransactionVerbose_Call) Return(_a0 *btcjson.TxRawResult, _a1 error) *ClientAdapterMock_GetRawTransactionVerbose_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_GetRawTransactionVerbose_Call) RunAndReturn(run func(*chainhash.Hash) (*btcjson.TxRawResult, error)) *ClientAdapterMock_GetRawTransactionVerbose_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransaction provides a mock function with given fields: txHash
func (_m *ClientAdapterMock) GetTransaction(txHash *chainhash.Hash) (*btcjson.GetTransactionResult, error) {
	ret := _m.Called(txHash)

	if len(ret) == 0 {
		panic("no return value specified for GetTransaction")
	}

	var r0 *btcjson.GetTransactionResult
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*btcjson.GetTransactionResult, error)); ok {
		return rf(txHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *btcjson.GetTransactionResult); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetTransactionResult)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_GetTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransaction'
type ClientAdapterMock_GetTransaction_Call struct {
	*mock.Call
}

// GetTransaction is a helper method to define mock.On call
//   - txHash *chainhash.Hash
func (_e *ClientAdapterMock_Expecter) GetTransaction(txHash interface{}) *ClientAdapterMock_GetTransaction_Call {
	return &ClientAdapterMock_GetTransaction_Call{Call: _e.mock.On("GetTransaction", txHash)}
}

func (_c *ClientAdapterMock_GetTransaction_Call) Run(run func(txHash *chainhash.Hash)) *ClientAdapterMock_GetTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *ClientAdapterMock_GetTransaction_Call) Return(_a0 *btcjson.GetTransactionResult, _a1 error) *ClientAdapterMock_GetTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_GetTransaction_Call) RunAndReturn(run func(*chainhash.Hash) (*btcjson.GetTransactionResult, error)) *ClientAdapterMock_GetTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// GetWalletInfo provides a mock function with given fields:
func (_m *ClientAdapterMock) GetWalletInfo() (*btcjson.GetWalletInfoResult, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetWalletInfo")
	}

	var r0 *btcjson.GetWalletInfoResult
	var r1 error
	if rf, ok := ret.Get(0).(func() (*btcjson.GetWalletInfoResult, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *btcjson.GetWalletInfoResult); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetWalletInfoResult)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_GetWalletInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWalletInfo'
type ClientAdapterMock_GetWalletInfo_Call struct {
	*mock.Call
}

// GetWalletInfo is a helper method to define mock.On call
func (_e *ClientAdapterMock_Expecter) GetWalletInfo() *ClientAdapterMock_GetWalletInfo_Call {
	return &ClientAdapterMock_GetWalletInfo_Call{Call: _e.mock.On("GetWalletInfo")}
}

func (_c *ClientAdapterMock_GetWalletInfo_Call) Run(run func()) *ClientAdapterMock_GetWalletInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientAdapterMock_GetWalletInfo_Call) Return(_a0 *btcjson.GetWalletInfoResult, _a1 error) *ClientAdapterMock_GetWalletInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_GetWalletInfo_Call) RunAndReturn(run func() (*btcjson.GetWalletInfoResult, error)) *ClientAdapterMock_GetWalletInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ImportAddressRescan provides a mock function with given fields: address, account, rescan
func (_m *ClientAdapterMock) ImportAddressRescan(address string, account string, rescan bool) error {
	ret := _m.Called(address, account, rescan)

	if len(ret) == 0 {
		panic("no return value specified for ImportAddressRescan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool) error); ok {
		r0 = rf(address, account, rescan)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientAdapterMock_ImportAddressRescan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportAddressRescan'
type ClientAdapterMock_ImportAddressRescan_Call struct {
	*mock.Call
}

// ImportAddressRescan is a helper method to define mock.On call
//   - address string
//   - account string
//   - rescan bool
func (_e *ClientAdapterMock_Expecter) ImportAddressRescan(address interface{}, account interface{}, rescan interface{}) *ClientAdapterMock_ImportAddressRescan_Call {
	return &ClientAdapterMock_ImportAddressRescan_Call{Call: _e.mock.On("ImportAddressRescan", address, account, rescan)}
}

func (_c *ClientAdapterMock_ImportAddressRescan_Call) Run(run func(address string, account string, rescan bool)) *ClientAdapterMock_ImportAddressRescan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *ClientAdapterMock_ImportAddressRescan_Call) Return(_a0 error) *ClientAdapterMock_ImportAddressRescan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientAdapterMock_ImportAddressRescan_Call) RunAndReturn(run func(string, string, bool) error) *ClientAdapterMock_ImportAddressRescan_Call {
	_c.Call.Return(run)
	return _c
}

// ImportPubKey provides a mock function with given fields: pubKey
func (_m *ClientAdapterMock) ImportPubKey(pubKey string) error {
	ret := _m.Called(pubKey)

	if len(ret) == 0 {
		panic("no return value specified for ImportPubKey")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(pubKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientAdapterMock_ImportPubKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportPubKey'
type ClientAdapterMock_ImportPubKey_Call struct {
	*mock.Call
}

// ImportPubKey is a helper method to define mock.On call
//   - pubKey string
func (_e *ClientAdapterMock_Expecter) ImportPubKey(pubKey interface{}) *ClientAdapterMock_ImportPubKey_Call {
	return &ClientAdapterMock_ImportPubKey_Call{Call: _e.mock.On("ImportPubKey", pubKey)}
}

func (_c *ClientAdapterMock_ImportPubKey_Call) Run(run func(pubKey string)) *ClientAdapterMock_ImportPubKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ClientAdapterMock_ImportPubKey_Call) Return(_a0 error) *ClientAdapterMock_ImportPubKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientAdapterMock_ImportPubKey_Call) RunAndReturn(run func(string) error) *ClientAdapterMock_ImportPubKey_Call {
	_c.Call.Return(run)
	return _c
}

// ImportPubKeyRescan provides a mock function with given fields: pubKey, rescan
func (_m *ClientAdapterMock) ImportPubKeyRescan(pubKey string, rescan bool) error {
	ret := _m.Called(pubKey, rescan)

	if len(ret) == 0 {
		panic("no return value specified for ImportPubKeyRescan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, bool) error); ok {
		r0 = rf(pubKey, rescan)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientAdapterMock_ImportPubKeyRescan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportPubKeyRescan'
type ClientAdapterMock_ImportPubKeyRescan_Call struct {
	*mock.Call
}

// ImportPubKeyRescan is a helper method to define mock.On call
//   - pubKey string
//   - rescan bool
func (_e *ClientAdapterMock_Expecter) ImportPubKeyRescan(pubKey interface{}, rescan interface{}) *ClientAdapterMock_ImportPubKeyRescan_Call {
	return &ClientAdapterMock_ImportPubKeyRescan_Call{Call: _e.mock.On("ImportPubKeyRescan", pubKey, rescan)}
}

func (_c *ClientAdapterMock_ImportPubKeyRescan_Call) Run(run func(pubKey string, rescan bool)) *ClientAdapterMock_ImportPubKeyRescan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(bool))
	})
	return _c
}

func (_c *ClientAdapterMock_ImportPubKeyRescan_Call) Return(_a0 error) *ClientAdapterMock_ImportPubKeyRescan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientAdapterMock_ImportPubKeyRescan_Call) RunAndReturn(run func(string, bool) error) *ClientAdapterMock_ImportPubKeyRescan_Call {
	_c.Call.Return(run)
	return _c
}

// ListUnspent provides a mock function with given fields:
func (_m *ClientAdapterMock) ListUnspent() ([]btcjson.ListUnspentResult, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ListUnspent")
	}

	var r0 []btcjson.ListUnspentResult
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]btcjson.ListUnspentResult, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []btcjson.ListUnspentResult); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]btcjson.ListUnspentResult)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_ListUnspent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUnspent'
type ClientAdapterMock_ListUnspent_Call struct {
	*mock.Call
}

// ListUnspent is a helper method to define mock.On call
func (_e *ClientAdapterMock_Expecter) ListUnspent() *ClientAdapterMock_ListUnspent_Call {
	return &ClientAdapterMock_ListUnspent_Call{Call: _e.mock.On("ListUnspent")}
}

func (_c *ClientAdapterMock_ListUnspent_Call) Run(run func()) *ClientAdapterMock_ListUnspent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientAdapterMock_ListUnspent_Call) Return(_a0 []btcjson.ListUnspentResult, _a1 error) *ClientAdapterMock_ListUnspent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_ListUnspent_Call) RunAndReturn(run func() ([]btcjson.ListUnspentResult, error)) *ClientAdapterMock_ListUnspent_Call {
	_c.Call.Return(run)
	return _c
}

// ListUnspentMinMaxAddresses provides a mock function with given fields: minConf, maxConf, addrs
func (_m *ClientAdapterMock) ListUnspentMinMaxAddresses(minConf int, maxConf int, addrs []btcutil.Address) ([]btcjson.ListUnspentResult, error) {
	ret := _m.Called(minConf, maxConf, addrs)

	if len(ret) == 0 {
		panic("no return value specified for ListUnspentMinMaxAddresses")
	}

	var r0 []btcjson.ListUnspentResult
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, []btcutil.Address) ([]btcjson.ListUnspentResult, error)); ok {
		return rf(minConf, maxConf, addrs)
	}
	if rf, ok := ret.Get(0).(func(int, int, []btcutil.Address) []btcjson.ListUnspentResult); ok {
		r0 = rf(minConf, maxConf, addrs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]btcjson.ListUnspentResult)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, []btcutil.Address) error); ok {
		r1 = rf(minConf, maxConf, addrs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_ListUnspentMinMaxAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUnspentMinMaxAddresses'
type ClientAdapterMock_ListUnspentMinMaxAddresses_Call struct {
	*mock.Call
}

// ListUnspentMinMaxAddresses is a helper method to define mock.On call
//   - minConf int
//   - maxConf int
//   - addrs []btcutil.Address
func (_e *ClientAdapterMock_Expecter) ListUnspentMinMaxAddresses(minConf interface{}, maxConf interface{}, addrs interface{}) *ClientAdapterMock_ListUnspentMinMaxAddresses_Call {
	return &ClientAdapterMock_ListUnspentMinMaxAddresses_Call{Call: _e.mock.On("ListUnspentMinMaxAddresses", minConf, maxConf, addrs)}
}

func (_c *ClientAdapterMock_ListUnspentMinMaxAddresses_Call) Run(run func(minConf int, maxConf int, addrs []btcutil.Address)) *ClientAdapterMock_ListUnspentMinMaxAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int), args[2].([]btcutil.Address))
	})
	return _c
}

func (_c *ClientAdapterMock_ListUnspentMinMaxAddresses_Call) Return(_a0 []btcjson.ListUnspentResult, _a1 error) *ClientAdapterMock_ListUnspentMinMaxAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_ListUnspentMinMaxAddresses_Call) RunAndReturn(run func(int, int, []btcutil.Address) ([]btcjson.ListUnspentResult, error)) *ClientAdapterMock_ListUnspentMinMaxAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// LoadWallet provides a mock function with given fields: walletName
func (_m *ClientAdapterMock) LoadWallet(walletName string) (*btcjson.LoadWalletResult, error) {
	ret := _m.Called(walletName)

	if len(ret) == 0 {
		panic("no return value specified for LoadWallet")
	}

	var r0 *btcjson.LoadWalletResult
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*btcjson.LoadWalletResult, error)); ok {
		return rf(walletName)
	}
	if rf, ok := ret.Get(0).(func(string) *btcjson.LoadWalletResult); ok {
		r0 = rf(walletName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.LoadWalletResult)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(walletName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_LoadWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadWallet'
type ClientAdapterMock_LoadWallet_Call struct {
	*mock.Call
}

// LoadWallet is a helper method to define mock.On call
//   - walletName string
func (_e *ClientAdapterMock_Expecter) LoadWallet(walletName interface{}) *ClientAdapterMock_LoadWallet_Call {
	return &ClientAdapterMock_LoadWallet_Call{Call: _e.mock.On("LoadWallet", walletName)}
}

func (_c *ClientAdapterMock_LoadWallet_Call) Run(run func(walletName string)) *ClientAdapterMock_LoadWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ClientAdapterMock_LoadWallet_Call) Return(_a0 *btcjson.LoadWalletResult, _a1 error) *ClientAdapterMock_LoadWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_LoadWallet_Call) RunAndReturn(run func(string) (*btcjson.LoadWalletResult, error)) *ClientAdapterMock_LoadWallet_Call {
	_c.Call.Return(run)
	return _c
}

// NextID provides a mock function with given fields:
func (_m *ClientAdapterMock) NextID() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NextID")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// ClientAdapterMock_NextID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NextID'
type ClientAdapterMock_NextID_Call struct {
	*mock.Call
}

// NextID is a helper method to define mock.On call
func (_e *ClientAdapterMock_Expecter) NextID() *ClientAdapterMock_NextID_Call {
	return &ClientAdapterMock_NextID_Call{Call: _e.mock.On("NextID")}
}

func (_c *ClientAdapterMock_NextID_Call) Run(run func()) *ClientAdapterMock_NextID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientAdapterMock_NextID_Call) Return(_a0 uint64) *ClientAdapterMock_NextID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientAdapterMock_NextID_Call) RunAndReturn(run func() uint64) *ClientAdapterMock_NextID_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function with given fields:
func (_m *ClientAdapterMock) Ping() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientAdapterMock_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type ClientAdapterMock_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
func (_e *ClientAdapterMock_Expecter) Ping() *ClientAdapterMock_Ping_Call {
	return &ClientAdapterMock_Ping_Call{Call: _e.mock.On("Ping")}
}

func (_c *ClientAdapterMock_Ping_Call) Run(run func()) *ClientAdapterMock_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ClientAdapterMock_Ping_Call) Return(_a0 error) *ClientAdapterMock_Ping_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientAdapterMock_Ping_Call) RunAndReturn(run func() error) *ClientAdapterMock_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// SendCmd provides a mock function with given fields: cmd
func (_m *ClientAdapterMock) SendCmd(cmd interface{}) chan *rpcclient.Response {
	ret := _m.Called(cmd)

	if len(ret) == 0 {
		panic("no return value specified for SendCmd")
	}

	var r0 chan *rpcclient.Response
	if rf, ok := ret.Get(0).(func(interface{}) chan *rpcclient.Response); ok {
		r0 = rf(cmd)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan *rpcclient.Response)
		}
	}

	return r0
}

// ClientAdapterMock_SendCmd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendCmd'
type ClientAdapterMock_SendCmd_Call struct {
	*mock.Call
}

// SendCmd is a helper method to define mock.On call
//   - cmd interface{}
func (_e *ClientAdapterMock_Expecter) SendCmd(cmd interface{}) *ClientAdapterMock_SendCmd_Call {
	return &ClientAdapterMock_SendCmd_Call{Call: _e.mock.On("SendCmd", cmd)}
}

func (_c *ClientAdapterMock_SendCmd_Call) Run(run func(cmd interface{})) *ClientAdapterMock_SendCmd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *ClientAdapterMock_SendCmd_Call) Return(_a0 chan *rpcclient.Response) *ClientAdapterMock_SendCmd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientAdapterMock_SendCmd_Call) RunAndReturn(run func(interface{}) chan *rpcclient.Response) *ClientAdapterMock_SendCmd_Call {
	_c.Call.Return(run)
	return _c
}

// SendRawTransaction provides a mock function with given fields: tx, allowHighFees
func (_m *ClientAdapterMock) SendRawTransaction(tx *wire.MsgTx, allowHighFees bool) (*chainhash.Hash, error) {
	ret := _m.Called(tx, allowHighFees)

	if len(ret) == 0 {
		panic("no return value specified for SendRawTransaction")
	}

	var r0 *chainhash.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, bool) (*chainhash.Hash, error)); ok {
		return rf(tx, allowHighFees)
	}
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, bool) *chainhash.Hash); ok {
		r0 = rf(tx, allowHighFees)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chainhash.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(*wire.MsgTx, bool) error); ok {
		r1 = rf(tx, allowHighFees)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_SendRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendRawTransaction'
type ClientAdapterMock_SendRawTransaction_Call struct {
	*mock.Call
}

// SendRawTransaction is a helper method to define mock.On call
//   - tx *wire.MsgTx
//   - allowHighFees bool
func (_e *ClientAdapterMock_Expecter) SendRawTransaction(tx interface{}, allowHighFees interface{}) *ClientAdapterMock_SendRawTransaction_Call {
	return &ClientAdapterMock_SendRawTransaction_Call{Call: _e.mock.On("SendRawTransaction", tx, allowHighFees)}
}

func (_c *ClientAdapterMock_SendRawTransaction_Call) Run(run func(tx *wire.MsgTx, allowHighFees bool)) *ClientAdapterMock_SendRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*wire.MsgTx), args[1].(bool))
	})
	return _c
}

func (_c *ClientAdapterMock_SendRawTransaction_Call) Return(_a0 *chainhash.Hash, _a1 error) *ClientAdapterMock_SendRawTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_SendRawTransaction_Call) RunAndReturn(run func(*wire.MsgTx, bool) (*chainhash.Hash, error)) *ClientAdapterMock_SendRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// SignRawTransactionWithKey provides a mock function with given fields: tx, privateKeysWIFs
func (_m *ClientAdapterMock) SignRawTransactionWithKey(tx *wire.MsgTx, privateKeysWIFs []string) (*wire.MsgTx, bool, error) {
	ret := _m.Called(tx, privateKeysWIFs)

	if len(ret) == 0 {
		panic("no return value specified for SignRawTransactionWithKey")
	}

	var r0 *wire.MsgTx
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, []string) (*wire.MsgTx, bool, error)); ok {
		return rf(tx, privateKeysWIFs)
	}
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, []string) *wire.MsgTx); ok {
		r0 = rf(tx, privateKeysWIFs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wire.MsgTx)
		}
	}

	if rf, ok := ret.Get(1).(func(*wire.MsgTx, []string) bool); ok {
		r1 = rf(tx, privateKeysWIFs)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(*wire.MsgTx, []string) error); ok {
		r2 = rf(tx, privateKeysWIFs)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ClientAdapterMock_SignRawTransactionWithKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignRawTransactionWithKey'
type ClientAdapterMock_SignRawTransactionWithKey_Call struct {
	*mock.Call
}

// SignRawTransactionWithKey is a helper method to define mock.On call
//   - tx *wire.MsgTx
//   - privateKeysWIFs []string
func (_e *ClientAdapterMock_Expecter) SignRawTransactionWithKey(tx interface{}, privateKeysWIFs interface{}) *ClientAdapterMock_SignRawTransactionWithKey_Call {
	return &ClientAdapterMock_SignRawTransactionWithKey_Call{Call: _e.mock.On("SignRawTransactionWithKey", tx, privateKeysWIFs)}
}

func (_c *ClientAdapterMock_SignRawTransactionWithKey_Call) Run(run func(tx *wire.MsgTx, privateKeysWIFs []string)) *ClientAdapterMock_SignRawTransactionWithKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*wire.MsgTx), args[1].([]string))
	})
	return _c
}

func (_c *ClientAdapterMock_SignRawTransactionWithKey_Call) Return(_a0 *wire.MsgTx, _a1 bool, _a2 error) *ClientAdapterMock_SignRawTransactionWithKey_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ClientAdapterMock_SignRawTransactionWithKey_Call) RunAndReturn(run func(*wire.MsgTx, []string) (*wire.MsgTx, bool, error)) *ClientAdapterMock_SignRawTransactionWithKey_Call {
	_c.Call.Return(run)
	return _c
}

// SignRawTransactionWithWallet provides a mock function with given fields: tx
func (_m *ClientAdapterMock) SignRawTransactionWithWallet(tx *wire.MsgTx) (*wire.MsgTx, bool, error) {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for SignRawTransactionWithWallet")
	}

	var r0 *wire.MsgTx
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(*wire.MsgTx) (*wire.MsgTx, bool, error)); ok {
		return rf(tx)
	}
	if rf, ok := ret.Get(0).(func(*wire.MsgTx) *wire.MsgTx); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wire.MsgTx)
		}
	}

	if rf, ok := ret.Get(1).(func(*wire.MsgTx) bool); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(*wire.MsgTx) error); ok {
		r2 = rf(tx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ClientAdapterMock_SignRawTransactionWithWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignRawTransactionWithWallet'
type ClientAdapterMock_SignRawTransactionWithWallet_Call struct {
	*mock.Call
}

// SignRawTransactionWithWallet is a helper method to define mock.On call
//   - tx *wire.MsgTx
func (_e *ClientAdapterMock_Expecter) SignRawTransactionWithWallet(tx interface{}) *ClientAdapterMock_SignRawTransactionWithWallet_Call {
	return &ClientAdapterMock_SignRawTransactionWithWallet_Call{Call: _e.mock.On("SignRawTransactionWithWallet", tx)}
}

func (_c *ClientAdapterMock_SignRawTransactionWithWallet_Call) Run(run func(tx *wire.MsgTx)) *ClientAdapterMock_SignRawTransactionWithWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*wire.MsgTx))
	})
	return _c
}

func (_c *ClientAdapterMock_SignRawTransactionWithWallet_Call) Return(_a0 *wire.MsgTx, _a1 bool, _a2 error) *ClientAdapterMock_SignRawTransactionWithWallet_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ClientAdapterMock_SignRawTransactionWithWallet_Call) RunAndReturn(run func(*wire.MsgTx) (*wire.MsgTx, bool, error)) *ClientAdapterMock_SignRawTransactionWithWallet_Call {
	_c.Call.Return(run)
	return _c
}

// WalletCreateFundedPsbt provides a mock function with given fields: inputs, outputs, locktime, options, bip32Derivs
func (_m *ClientAdapterMock) WalletCreateFundedPsbt(inputs []btcjson.PsbtInput, outputs []btcjson.PsbtOutput, locktime *uint32, options *btcjson.WalletCreateFundedPsbtOpts, bip32Derivs *bool) (*btcjson.WalletCreateFundedPsbtResult, error) {
	ret := _m.Called(inputs, outputs, locktime, options, bip32Derivs)

	if len(ret) == 0 {
		panic("no return value specified for WalletCreateFundedPsbt")
	}

	var r0 *btcjson.WalletCreateFundedPsbtResult
	var r1 error
	if rf, ok := ret.Get(0).(func([]btcjson.PsbtInput, []btcjson.PsbtOutput, *uint32, *btcjson.WalletCreateFundedPsbtOpts, *bool) (*btcjson.WalletCreateFundedPsbtResult, error)); ok {
		return rf(inputs, outputs, locktime, options, bip32Derivs)
	}
	if rf, ok := ret.Get(0).(func([]btcjson.PsbtInput, []btcjson.PsbtOutput, *uint32, *btcjson.WalletCreateFundedPsbtOpts, *bool) *btcjson.WalletCreateFundedPsbtResult); ok {
		r0 = rf(inputs, outputs, locktime, options, bip32Derivs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.WalletCreateFundedPsbtResult)
		}
	}

	if rf, ok := ret.Get(1).(func([]btcjson.PsbtInput, []btcjson.PsbtOutput, *uint32, *btcjson.WalletCreateFundedPsbtOpts, *bool) error); ok {
		r1 = rf(inputs, outputs, locktime, options, bip32Derivs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientAdapterMock_WalletCreateFundedPsbt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletCreateFundedPsbt'
type ClientAdapterMock_WalletCreateFundedPsbt_Call struct {
	*mock.Call
}

// WalletCreateFundedPsbt is a helper method to define mock.On call
//   - inputs []btcjson.PsbtInput
//   - outputs []btcjson.PsbtOutput
//   - locktime *uint32
//   - options *btcjson.WalletCreateFundedPsbtOpts
//   - bip32Derivs *bool
func (_e *ClientAdapterMock_Expecter) WalletCreateFundedPsbt(inputs interface{}, outputs interface{}, locktime interface{}, options interface{}, bip32Derivs interface{}) *ClientAdapterMock_WalletCreateFundedPsbt_Call {
	return &ClientAdapterMock_WalletCreateFundedPsbt_Call{Call: _e.mock.On("WalletCreateFundedPsbt", inputs, outputs, locktime, options, bip32Derivs)}
}

func (_c *ClientAdapterMock_WalletCreateFundedPsbt_Call) Run(run func(inputs []btcjson.PsbtInput, outputs []btcjson.PsbtOutput, locktime *uint32, options *btcjson.WalletCreateFundedPsbtOpts, bip32Derivs *bool)) *ClientAdapterMock_WalletCreateFundedPsbt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]btcjson.PsbtInput), args[1].([]btcjson.PsbtOutput), args[2].(*uint32), args[3].(*btcjson.WalletCreateFundedPsbtOpts), args[4].(*bool))
	})
	return _c
}

func (_c *ClientAdapterMock_WalletCreateFundedPsbt_Call) Return(_a0 *btcjson.WalletCreateFundedPsbtResult, _a1 error) *ClientAdapterMock_WalletCreateFundedPsbt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientAdapterMock_WalletCreateFundedPsbt_Call) RunAndReturn(run func([]btcjson.PsbtInput, []btcjson.PsbtOutput, *uint32, *btcjson.WalletCreateFundedPsbtOpts, *bool) (*btcjson.WalletCreateFundedPsbtResult, error)) *ClientAdapterMock_WalletCreateFundedPsbt_Call {
	_c.Call.Return(run)
	return _c
}

// WalletPassphrase provides a mock function with given fields: passphrase, timeoutSecs
func (_m *ClientAdapterMock) WalletPassphrase(passphrase string, timeoutSecs int64) error {
	ret := _m.Called(passphrase, timeoutSecs)

	if len(ret) == 0 {
		panic("no return value specified for WalletPassphrase")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int64) error); ok {
		r0 = rf(passphrase, timeoutSecs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientAdapterMock_WalletPassphrase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletPassphrase'
type ClientAdapterMock_WalletPassphrase_Call struct {
	*mock.Call
}

// WalletPassphrase is a helper method to define mock.On call
//   - passphrase string
//   - timeoutSecs int64
func (_e *ClientAdapterMock_Expecter) WalletPassphrase(passphrase interface{}, timeoutSecs interface{}) *ClientAdapterMock_WalletPassphrase_Call {
	return &ClientAdapterMock_WalletPassphrase_Call{Call: _e.mock.On("WalletPassphrase", passphrase, timeoutSecs)}
}

func (_c *ClientAdapterMock_WalletPassphrase_Call) Run(run func(passphrase string, timeoutSecs int64)) *ClientAdapterMock_WalletPassphrase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64))
	})
	return _c
}

func (_c *ClientAdapterMock_WalletPassphrase_Call) Return(_a0 error) *ClientAdapterMock_WalletPassphrase_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ClientAdapterMock_WalletPassphrase_Call) RunAndReturn(run func(string, int64) error) *ClientAdapterMock_WalletPassphrase_Call {
	_c.Call.Return(run)
	return _c
}

// NewClientAdapterMock creates a new instance of ClientAdapterMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientAdapterMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientAdapterMock {
	mock := &ClientAdapterMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
