// Code generated by mockery v2.51.1. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"
	bindings "github.com/rsksmart/liquidity-provider-server/internal/adapters/dataproviders/rootstock/bindings"

	mock "github.com/stretchr/testify/mock"

	rootstock "github.com/rsksmart/liquidity-provider-server/internal/adapters/dataproviders/rootstock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// PegoutContractAdapterMock is an autogenerated mock type for the PegoutContractAdapter type
type PegoutContractAdapterMock struct {
	mock.Mock
}

type PegoutContractAdapterMock_Expecter struct {
	mock *mock.Mock
}

func (_m *PegoutContractAdapterMock) EXPECT() *PegoutContractAdapterMock_Expecter {
	return &PegoutContractAdapterMock_Expecter{mock: &_m.Mock}
}

// Caller provides a mock function with no fields
func (_m *PegoutContractAdapterMock) Caller() rootstock.ContractCallerBinding {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Caller")
	}

	var r0 rootstock.ContractCallerBinding
	if rf, ok := ret.Get(0).(func() rootstock.ContractCallerBinding); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rootstock.ContractCallerBinding)
		}
	}

	return r0
}

// PegoutContractAdapterMock_Caller_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Caller'
type PegoutContractAdapterMock_Caller_Call struct {
	*mock.Call
}

// Caller is a helper method to define mock.On call
func (_e *PegoutContractAdapterMock_Expecter) Caller() *PegoutContractAdapterMock_Caller_Call {
	return &PegoutContractAdapterMock_Caller_Call{Call: _e.mock.On("Caller")}
}

func (_c *PegoutContractAdapterMock_Caller_Call) Run(run func()) *PegoutContractAdapterMock_Caller_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PegoutContractAdapterMock_Caller_Call) Return(_a0 rootstock.ContractCallerBinding) *PegoutContractAdapterMock_Caller_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PegoutContractAdapterMock_Caller_Call) RunAndReturn(run func() rootstock.ContractCallerBinding) *PegoutContractAdapterMock_Caller_Call {
	_c.Call.Return(run)
	return _c
}

// DepositEventIteratorAdapter provides a mock function with given fields: rawIterator
func (_m *PegoutContractAdapterMock) DepositEventIteratorAdapter(rawIterator *bindings.IPegOutPegOutDepositIterator) rootstock.EventIteratorAdapter[bindings.IPegOutPegOutDeposit] {
	ret := _m.Called(rawIterator)

	if len(ret) == 0 {
		panic("no return value specified for DepositEventIteratorAdapter")
	}

	var r0 rootstock.EventIteratorAdapter[bindings.IPegOutPegOutDeposit]
	if rf, ok := ret.Get(0).(func(*bindings.IPegOutPegOutDepositIterator) rootstock.EventIteratorAdapter[bindings.IPegOutPegOutDeposit]); ok {
		r0 = rf(rawIterator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rootstock.EventIteratorAdapter[bindings.IPegOutPegOutDeposit])
		}
	}

	return r0
}

// PegoutContractAdapterMock_DepositEventIteratorAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DepositEventIteratorAdapter'
type PegoutContractAdapterMock_DepositEventIteratorAdapter_Call struct {
	*mock.Call
}

// DepositEventIteratorAdapter is a helper method to define mock.On call
//   - rawIterator *bindings.IPegOutPegOutDepositIterator
func (_e *PegoutContractAdapterMock_Expecter) DepositEventIteratorAdapter(rawIterator interface{}) *PegoutContractAdapterMock_DepositEventIteratorAdapter_Call {
	return &PegoutContractAdapterMock_DepositEventIteratorAdapter_Call{Call: _e.mock.On("DepositEventIteratorAdapter", rawIterator)}
}

func (_c *PegoutContractAdapterMock_DepositEventIteratorAdapter_Call) Run(run func(rawIterator *bindings.IPegOutPegOutDepositIterator)) *PegoutContractAdapterMock_DepositEventIteratorAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bindings.IPegOutPegOutDepositIterator))
	})
	return _c
}

func (_c *PegoutContractAdapterMock_DepositEventIteratorAdapter_Call) Return(_a0 rootstock.EventIteratorAdapter[bindings.IPegOutPegOutDeposit]) *PegoutContractAdapterMock_DepositEventIteratorAdapter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PegoutContractAdapterMock_DepositEventIteratorAdapter_Call) RunAndReturn(run func(*bindings.IPegOutPegOutDepositIterator) rootstock.EventIteratorAdapter[bindings.IPegOutPegOutDeposit]) *PegoutContractAdapterMock_DepositEventIteratorAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// FilterPegOutDeposit provides a mock function with given fields: opts, quoteHash, sender, timestamp
func (_m *PegoutContractAdapterMock) FilterPegOutDeposit(opts *bind.FilterOpts, quoteHash [][32]byte, sender []common.Address, timestamp []*big.Int) (*bindings.IPegOutPegOutDepositIterator, error) {
	ret := _m.Called(opts, quoteHash, sender, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for FilterPegOutDeposit")
	}

	var r0 *bindings.IPegOutPegOutDepositIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []*big.Int) (*bindings.IPegOutPegOutDepositIterator, error)); ok {
		return rf(opts, quoteHash, sender, timestamp)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []*big.Int) *bindings.IPegOutPegOutDepositIterator); ok {
		r0 = rf(opts, quoteHash, sender, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.IPegOutPegOutDepositIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []common.Address, []*big.Int) error); ok {
		r1 = rf(opts, quoteHash, sender, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractAdapterMock_FilterPegOutDeposit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterPegOutDeposit'
type PegoutContractAdapterMock_FilterPegOutDeposit_Call struct {
	*mock.Call
}

// FilterPegOutDeposit is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - quoteHash [][32]byte
//   - sender []common.Address
//   - timestamp []*big.Int
func (_e *PegoutContractAdapterMock_Expecter) FilterPegOutDeposit(opts interface{}, quoteHash interface{}, sender interface{}, timestamp interface{}) *PegoutContractAdapterMock_FilterPegOutDeposit_Call {
	return &PegoutContractAdapterMock_FilterPegOutDeposit_Call{Call: _e.mock.On("FilterPegOutDeposit", opts, quoteHash, sender, timestamp)}
}

func (_c *PegoutContractAdapterMock_FilterPegOutDeposit_Call) Run(run func(opts *bind.FilterOpts, quoteHash [][32]byte, sender []common.Address, timestamp []*big.Int)) *PegoutContractAdapterMock_FilterPegOutDeposit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]common.Address), args[3].([]*big.Int))
	})
	return _c
}

func (_c *PegoutContractAdapterMock_FilterPegOutDeposit_Call) Return(_a0 *bindings.IPegOutPegOutDepositIterator, _a1 error) *PegoutContractAdapterMock_FilterPegOutDeposit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractAdapterMock_FilterPegOutDeposit_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []common.Address, []*big.Int) (*bindings.IPegOutPegOutDepositIterator, error)) *PegoutContractAdapterMock_FilterPegOutDeposit_Call {
	_c.Call.Return(run)
	return _c
}

// GetFeePercentage provides a mock function with given fields: opts
func (_m *PegoutContractAdapterMock) GetFeePercentage(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetFeePercentage")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractAdapterMock_GetFeePercentage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFeePercentage'
type PegoutContractAdapterMock_GetFeePercentage_Call struct {
	*mock.Call
}

// GetFeePercentage is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *PegoutContractAdapterMock_Expecter) GetFeePercentage(opts interface{}) *PegoutContractAdapterMock_GetFeePercentage_Call {
	return &PegoutContractAdapterMock_GetFeePercentage_Call{Call: _e.mock.On("GetFeePercentage", opts)}
}

func (_c *PegoutContractAdapterMock_GetFeePercentage_Call) Run(run func(opts *bind.CallOpts)) *PegoutContractAdapterMock_GetFeePercentage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *PegoutContractAdapterMock_GetFeePercentage_Call) Return(_a0 *big.Int, _a1 error) *PegoutContractAdapterMock_GetFeePercentage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractAdapterMock_GetFeePercentage_Call) RunAndReturn(run func(*bind.CallOpts) (*big.Int, error)) *PegoutContractAdapterMock_GetFeePercentage_Call {
	_c.Call.Return(run)
	return _c
}

// HashPegOutQuote provides a mock function with given fields: opts, quote
func (_m *PegoutContractAdapterMock) HashPegOutQuote(opts *bind.CallOpts, quote bindings.QuotesPegOutQuote) ([32]byte, error) {
	ret := _m.Called(opts, quote)

	if len(ret) == 0 {
		panic("no return value specified for HashPegOutQuote")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, bindings.QuotesPegOutQuote) ([32]byte, error)); ok {
		return rf(opts, quote)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, bindings.QuotesPegOutQuote) [32]byte); ok {
		r0 = rf(opts, quote)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, bindings.QuotesPegOutQuote) error); ok {
		r1 = rf(opts, quote)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractAdapterMock_HashPegOutQuote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashPegOutQuote'
type PegoutContractAdapterMock_HashPegOutQuote_Call struct {
	*mock.Call
}

// HashPegOutQuote is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - quote bindings.QuotesPegOutQuote
func (_e *PegoutContractAdapterMock_Expecter) HashPegOutQuote(opts interface{}, quote interface{}) *PegoutContractAdapterMock_HashPegOutQuote_Call {
	return &PegoutContractAdapterMock_HashPegOutQuote_Call{Call: _e.mock.On("HashPegOutQuote", opts, quote)}
}

func (_c *PegoutContractAdapterMock_HashPegOutQuote_Call) Run(run func(opts *bind.CallOpts, quote bindings.QuotesPegOutQuote)) *PegoutContractAdapterMock_HashPegOutQuote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(bindings.QuotesPegOutQuote))
	})
	return _c
}

func (_c *PegoutContractAdapterMock_HashPegOutQuote_Call) Return(_a0 [32]byte, _a1 error) *PegoutContractAdapterMock_HashPegOutQuote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractAdapterMock_HashPegOutQuote_Call) RunAndReturn(run func(*bind.CallOpts, bindings.QuotesPegOutQuote) ([32]byte, error)) *PegoutContractAdapterMock_HashPegOutQuote_Call {
	_c.Call.Return(run)
	return _c
}

// IsQuoteCompleted provides a mock function with given fields: opts, quoteHash
func (_m *PegoutContractAdapterMock) IsQuoteCompleted(opts *bind.CallOpts, quoteHash [32]byte) (bool, error) {
	ret := _m.Called(opts, quoteHash)

	if len(ret) == 0 {
		panic("no return value specified for IsQuoteCompleted")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (bool, error)); ok {
		return rf(opts, quoteHash)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) bool); ok {
		r0 = rf(opts, quoteHash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, quoteHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractAdapterMock_IsQuoteCompleted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsQuoteCompleted'
type PegoutContractAdapterMock_IsQuoteCompleted_Call struct {
	*mock.Call
}

// IsQuoteCompleted is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - quoteHash [32]byte
func (_e *PegoutContractAdapterMock_Expecter) IsQuoteCompleted(opts interface{}, quoteHash interface{}) *PegoutContractAdapterMock_IsQuoteCompleted_Call {
	return &PegoutContractAdapterMock_IsQuoteCompleted_Call{Call: _e.mock.On("IsQuoteCompleted", opts, quoteHash)}
}

func (_c *PegoutContractAdapterMock_IsQuoteCompleted_Call) Run(run func(opts *bind.CallOpts, quoteHash [32]byte)) *PegoutContractAdapterMock_IsQuoteCompleted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *PegoutContractAdapterMock_IsQuoteCompleted_Call) Return(_a0 bool, _a1 error) *PegoutContractAdapterMock_IsQuoteCompleted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractAdapterMock_IsQuoteCompleted_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (bool, error)) *PegoutContractAdapterMock_IsQuoteCompleted_Call {
	_c.Call.Return(run)
	return _c
}

// RefundPegOut provides a mock function with given fields: opts, quoteHash, btcTx, btcBlockHeaderHash, partialMerkleTree, merkleBranchHashes
func (_m *PegoutContractAdapterMock) RefundPegOut(opts *bind.TransactOpts, quoteHash [32]byte, btcTx []byte, btcBlockHeaderHash [32]byte, partialMerkleTree *big.Int, merkleBranchHashes [][32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, quoteHash, btcTx, btcBlockHeaderHash, partialMerkleTree, merkleBranchHashes)

	if len(ret) == 0 {
		panic("no return value specified for RefundPegOut")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, []byte, [32]byte, *big.Int, [][32]byte) (*types.Transaction, error)); ok {
		return rf(opts, quoteHash, btcTx, btcBlockHeaderHash, partialMerkleTree, merkleBranchHashes)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, []byte, [32]byte, *big.Int, [][32]byte) *types.Transaction); ok {
		r0 = rf(opts, quoteHash, btcTx, btcBlockHeaderHash, partialMerkleTree, merkleBranchHashes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte, []byte, [32]byte, *big.Int, [][32]byte) error); ok {
		r1 = rf(opts, quoteHash, btcTx, btcBlockHeaderHash, partialMerkleTree, merkleBranchHashes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractAdapterMock_RefundPegOut_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefundPegOut'
type PegoutContractAdapterMock_RefundPegOut_Call struct {
	*mock.Call
}

// RefundPegOut is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - quoteHash [32]byte
//   - btcTx []byte
//   - btcBlockHeaderHash [32]byte
//   - partialMerkleTree *big.Int
//   - merkleBranchHashes [][32]byte
func (_e *PegoutContractAdapterMock_Expecter) RefundPegOut(opts interface{}, quoteHash interface{}, btcTx interface{}, btcBlockHeaderHash interface{}, partialMerkleTree interface{}, merkleBranchHashes interface{}) *PegoutContractAdapterMock_RefundPegOut_Call {
	return &PegoutContractAdapterMock_RefundPegOut_Call{Call: _e.mock.On("RefundPegOut", opts, quoteHash, btcTx, btcBlockHeaderHash, partialMerkleTree, merkleBranchHashes)}
}

func (_c *PegoutContractAdapterMock_RefundPegOut_Call) Run(run func(opts *bind.TransactOpts, quoteHash [32]byte, btcTx []byte, btcBlockHeaderHash [32]byte, partialMerkleTree *big.Int, merkleBranchHashes [][32]byte)) *PegoutContractAdapterMock_RefundPegOut_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte), args[2].([]byte), args[3].([32]byte), args[4].(*big.Int), args[5].([][32]byte))
	})
	return _c
}

func (_c *PegoutContractAdapterMock_RefundPegOut_Call) Return(_a0 *types.Transaction, _a1 error) *PegoutContractAdapterMock_RefundPegOut_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractAdapterMock_RefundPegOut_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte, []byte, [32]byte, *big.Int, [][32]byte) (*types.Transaction, error)) *PegoutContractAdapterMock_RefundPegOut_Call {
	_c.Call.Return(run)
	return _c
}

// RefundUserPegOut provides a mock function with given fields: opts, quoteHash
func (_m *PegoutContractAdapterMock) RefundUserPegOut(opts *bind.TransactOpts, quoteHash [32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, quoteHash)

	if len(ret) == 0 {
		panic("no return value specified for RefundUserPegOut")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)); ok {
		return rf(opts, quoteHash)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) *types.Transaction); ok {
		r0 = rf(opts, quoteHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte) error); ok {
		r1 = rf(opts, quoteHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PegoutContractAdapterMock_RefundUserPegOut_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefundUserPegOut'
type PegoutContractAdapterMock_RefundUserPegOut_Call struct {
	*mock.Call
}

// RefundUserPegOut is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - quoteHash [32]byte
func (_e *PegoutContractAdapterMock_Expecter) RefundUserPegOut(opts interface{}, quoteHash interface{}) *PegoutContractAdapterMock_RefundUserPegOut_Call {
	return &PegoutContractAdapterMock_RefundUserPegOut_Call{Call: _e.mock.On("RefundUserPegOut", opts, quoteHash)}
}

func (_c *PegoutContractAdapterMock_RefundUserPegOut_Call) Run(run func(opts *bind.TransactOpts, quoteHash [32]byte)) *PegoutContractAdapterMock_RefundUserPegOut_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *PegoutContractAdapterMock_RefundUserPegOut_Call) Return(_a0 *types.Transaction, _a1 error) *PegoutContractAdapterMock_RefundUserPegOut_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PegoutContractAdapterMock_RefundUserPegOut_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)) *PegoutContractAdapterMock_RefundUserPegOut_Call {
	_c.Call.Return(run)
	return _c
}

// NewPegoutContractAdapterMock creates a new instance of PegoutContractAdapterMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPegoutContractAdapterMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *PegoutContractAdapterMock {
	mock := &PegoutContractAdapterMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
