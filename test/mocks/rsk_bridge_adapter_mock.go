// Code generated by mockery v2.51.1. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	bindings "github.com/rsksmart/liquidity-provider-server/internal/adapters/dataproviders/rootstock/bindings"
	mock "github.com/stretchr/testify/mock"

	rootstock "github.com/rsksmart/liquidity-provider-server/internal/adapters/dataproviders/rootstock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// RskBridgeAdapterMock is an autogenerated mock type for the RskBridgeAdapter type
type RskBridgeAdapterMock struct {
	mock.Mock
}

type RskBridgeAdapterMock_Expecter struct {
	mock *mock.Mock
}

func (_m *RskBridgeAdapterMock) EXPECT() *RskBridgeAdapterMock_Expecter {
	return &RskBridgeAdapterMock_Expecter{mock: &_m.Mock}
}

// BatchPegOutCreatedIteratorAdapter provides a mock function with given fields: rawIterator
func (_m *RskBridgeAdapterMock) BatchPegOutCreatedIteratorAdapter(rawIterator *bindings.RskBridgeBatchPegoutCreatedIterator) rootstock.EventIteratorAdapter[bindings.RskBridgeBatchPegoutCreated] {
	ret := _m.Called(rawIterator)

	if len(ret) == 0 {
		panic("no return value specified for BatchPegOutCreatedIteratorAdapter")
	}

	var r0 rootstock.EventIteratorAdapter[bindings.RskBridgeBatchPegoutCreated]
	if rf, ok := ret.Get(0).(func(*bindings.RskBridgeBatchPegoutCreatedIterator) rootstock.EventIteratorAdapter[bindings.RskBridgeBatchPegoutCreated]); ok {
		r0 = rf(rawIterator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rootstock.EventIteratorAdapter[bindings.RskBridgeBatchPegoutCreated])
		}
	}

	return r0
}

// RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchPegOutCreatedIteratorAdapter'
type RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call struct {
	*mock.Call
}

// BatchPegOutCreatedIteratorAdapter is a helper method to define mock.On call
//   - rawIterator *bindings.RskBridgeBatchPegoutCreatedIterator
func (_e *RskBridgeAdapterMock_Expecter) BatchPegOutCreatedIteratorAdapter(rawIterator interface{}) *RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call {
	return &RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call{Call: _e.mock.On("BatchPegOutCreatedIteratorAdapter", rawIterator)}
}

func (_c *RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call) Run(run func(rawIterator *bindings.RskBridgeBatchPegoutCreatedIterator)) *RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bindings.RskBridgeBatchPegoutCreatedIterator))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call) Return(_a0 rootstock.EventIteratorAdapter[bindings.RskBridgeBatchPegoutCreated]) *RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call) RunAndReturn(run func(*bindings.RskBridgeBatchPegoutCreatedIterator) rootstock.EventIteratorAdapter[bindings.RskBridgeBatchPegoutCreated]) *RskBridgeAdapterMock_BatchPegOutCreatedIteratorAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// FilterBatchPegoutCreated provides a mock function with given fields: opts, btcTxHash
func (_m *RskBridgeAdapterMock) FilterBatchPegoutCreated(opts *bind.FilterOpts, btcTxHash [][32]byte) (*bindings.RskBridgeBatchPegoutCreatedIterator, error) {
	ret := _m.Called(opts, btcTxHash)

	if len(ret) == 0 {
		panic("no return value specified for FilterBatchPegoutCreated")
	}

	var r0 *bindings.RskBridgeBatchPegoutCreatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) (*bindings.RskBridgeBatchPegoutCreatedIterator, error)); ok {
		return rf(opts, btcTxHash)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) *bindings.RskBridgeBatchPegoutCreatedIterator); ok {
		r0 = rf(opts, btcTxHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RskBridgeBatchPegoutCreatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte) error); ok {
		r1 = rf(opts, btcTxHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_FilterBatchPegoutCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterBatchPegoutCreated'
type RskBridgeAdapterMock_FilterBatchPegoutCreated_Call struct {
	*mock.Call
}

// FilterBatchPegoutCreated is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - btcTxHash [][32]byte
func (_e *RskBridgeAdapterMock_Expecter) FilterBatchPegoutCreated(opts interface{}, btcTxHash interface{}) *RskBridgeAdapterMock_FilterBatchPegoutCreated_Call {
	return &RskBridgeAdapterMock_FilterBatchPegoutCreated_Call{Call: _e.mock.On("FilterBatchPegoutCreated", opts, btcTxHash)}
}

func (_c *RskBridgeAdapterMock_FilterBatchPegoutCreated_Call) Run(run func(opts *bind.FilterOpts, btcTxHash [][32]byte)) *RskBridgeAdapterMock_FilterBatchPegoutCreated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_FilterBatchPegoutCreated_Call) Return(_a0 *bindings.RskBridgeBatchPegoutCreatedIterator, _a1 error) *RskBridgeAdapterMock_FilterBatchPegoutCreated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_FilterBatchPegoutCreated_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte) (*bindings.RskBridgeBatchPegoutCreatedIterator, error)) *RskBridgeAdapterMock_FilterBatchPegoutCreated_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveFederationCreationBlockHeight provides a mock function with given fields: opts
func (_m *RskBridgeAdapterMock) GetActiveFederationCreationBlockHeight(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveFederationCreationBlockHeight")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveFederationCreationBlockHeight'
type RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call struct {
	*mock.Call
}

// GetActiveFederationCreationBlockHeight is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RskBridgeAdapterMock_Expecter) GetActiveFederationCreationBlockHeight(opts interface{}) *RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call {
	return &RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call{Call: _e.mock.On("GetActiveFederationCreationBlockHeight", opts)}
}

func (_c *RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call) Run(run func(opts *bind.CallOpts)) *RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call) Return(_a0 *big.Int, _a1 error) *RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call) RunAndReturn(run func(*bind.CallOpts) (*big.Int, error)) *RskBridgeAdapterMock_GetActiveFederationCreationBlockHeight_Call {
	_c.Call.Return(run)
	return _c
}

// GetActivePowpegRedeemScript provides a mock function with given fields: opts
func (_m *RskBridgeAdapterMock) GetActivePowpegRedeemScript(opts *bind.CallOpts) ([]byte, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetActivePowpegRedeemScript")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([]byte, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActivePowpegRedeemScript'
type RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call struct {
	*mock.Call
}

// GetActivePowpegRedeemScript is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RskBridgeAdapterMock_Expecter) GetActivePowpegRedeemScript(opts interface{}) *RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call {
	return &RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call{Call: _e.mock.On("GetActivePowpegRedeemScript", opts)}
}

func (_c *RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call) Run(run func(opts *bind.CallOpts)) *RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call) Return(_a0 []byte, _a1 error) *RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call) RunAndReturn(run func(*bind.CallOpts) ([]byte, error)) *RskBridgeAdapterMock_GetActivePowpegRedeemScript_Call {
	_c.Call.Return(run)
	return _c
}

// GetBtcBlockchainBestChainHeight provides a mock function with given fields: opts
func (_m *RskBridgeAdapterMock) GetBtcBlockchainBestChainHeight(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetBtcBlockchainBestChainHeight")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBtcBlockchainBestChainHeight'
type RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call struct {
	*mock.Call
}

// GetBtcBlockchainBestChainHeight is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RskBridgeAdapterMock_Expecter) GetBtcBlockchainBestChainHeight(opts interface{}) *RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call {
	return &RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call{Call: _e.mock.On("GetBtcBlockchainBestChainHeight", opts)}
}

func (_c *RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call) Run(run func(opts *bind.CallOpts)) *RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call) Return(_a0 *big.Int, _a1 error) *RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call) RunAndReturn(run func(*bind.CallOpts) (*big.Int, error)) *RskBridgeAdapterMock_GetBtcBlockchainBestChainHeight_Call {
	_c.Call.Return(run)
	return _c
}

// GetFederationAddress provides a mock function with given fields: opts
func (_m *RskBridgeAdapterMock) GetFederationAddress(opts *bind.CallOpts) (string, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetFederationAddress")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (string, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_GetFederationAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFederationAddress'
type RskBridgeAdapterMock_GetFederationAddress_Call struct {
	*mock.Call
}

// GetFederationAddress is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RskBridgeAdapterMock_Expecter) GetFederationAddress(opts interface{}) *RskBridgeAdapterMock_GetFederationAddress_Call {
	return &RskBridgeAdapterMock_GetFederationAddress_Call{Call: _e.mock.On("GetFederationAddress", opts)}
}

func (_c *RskBridgeAdapterMock_GetFederationAddress_Call) Run(run func(opts *bind.CallOpts)) *RskBridgeAdapterMock_GetFederationAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_GetFederationAddress_Call) Return(_a0 string, _a1 error) *RskBridgeAdapterMock_GetFederationAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_GetFederationAddress_Call) RunAndReturn(run func(*bind.CallOpts) (string, error)) *RskBridgeAdapterMock_GetFederationAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetFederationSize provides a mock function with given fields: opts
func (_m *RskBridgeAdapterMock) GetFederationSize(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetFederationSize")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_GetFederationSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFederationSize'
type RskBridgeAdapterMock_GetFederationSize_Call struct {
	*mock.Call
}

// GetFederationSize is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RskBridgeAdapterMock_Expecter) GetFederationSize(opts interface{}) *RskBridgeAdapterMock_GetFederationSize_Call {
	return &RskBridgeAdapterMock_GetFederationSize_Call{Call: _e.mock.On("GetFederationSize", opts)}
}

func (_c *RskBridgeAdapterMock_GetFederationSize_Call) Run(run func(opts *bind.CallOpts)) *RskBridgeAdapterMock_GetFederationSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_GetFederationSize_Call) Return(_a0 *big.Int, _a1 error) *RskBridgeAdapterMock_GetFederationSize_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_GetFederationSize_Call) RunAndReturn(run func(*bind.CallOpts) (*big.Int, error)) *RskBridgeAdapterMock_GetFederationSize_Call {
	_c.Call.Return(run)
	return _c
}

// GetFederationThreshold provides a mock function with given fields: opts
func (_m *RskBridgeAdapterMock) GetFederationThreshold(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetFederationThreshold")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_GetFederationThreshold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFederationThreshold'
type RskBridgeAdapterMock_GetFederationThreshold_Call struct {
	*mock.Call
}

// GetFederationThreshold is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RskBridgeAdapterMock_Expecter) GetFederationThreshold(opts interface{}) *RskBridgeAdapterMock_GetFederationThreshold_Call {
	return &RskBridgeAdapterMock_GetFederationThreshold_Call{Call: _e.mock.On("GetFederationThreshold", opts)}
}

func (_c *RskBridgeAdapterMock_GetFederationThreshold_Call) Run(run func(opts *bind.CallOpts)) *RskBridgeAdapterMock_GetFederationThreshold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_GetFederationThreshold_Call) Return(_a0 *big.Int, _a1 error) *RskBridgeAdapterMock_GetFederationThreshold_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_GetFederationThreshold_Call) RunAndReturn(run func(*bind.CallOpts) (*big.Int, error)) *RskBridgeAdapterMock_GetFederationThreshold_Call {
	_c.Call.Return(run)
	return _c
}

// GetFederatorPublicKeyOfType provides a mock function with given fields: opts, index, atype
func (_m *RskBridgeAdapterMock) GetFederatorPublicKeyOfType(opts *bind.CallOpts, index *big.Int, atype string) ([]byte, error) {
	ret := _m.Called(opts, index, atype)

	if len(ret) == 0 {
		panic("no return value specified for GetFederatorPublicKeyOfType")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int, string) ([]byte, error)); ok {
		return rf(opts, index, atype)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int, string) []byte); ok {
		r0 = rf(opts, index, atype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int, string) error); ok {
		r1 = rf(opts, index, atype)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFederatorPublicKeyOfType'
type RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call struct {
	*mock.Call
}

// GetFederatorPublicKeyOfType is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - index *big.Int
//   - atype string
func (_e *RskBridgeAdapterMock_Expecter) GetFederatorPublicKeyOfType(opts interface{}, index interface{}, atype interface{}) *RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call {
	return &RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call{Call: _e.mock.On("GetFederatorPublicKeyOfType", opts, index, atype)}
}

func (_c *RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call) Run(run func(opts *bind.CallOpts, index *big.Int, atype string)) *RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(*big.Int), args[2].(string))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call) Return(_a0 []byte, _a1 error) *RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call) RunAndReturn(run func(*bind.CallOpts, *big.Int, string) ([]byte, error)) *RskBridgeAdapterMock_GetFederatorPublicKeyOfType_Call {
	_c.Call.Return(run)
	return _c
}

// GetMinimumLockTxValue provides a mock function with given fields: opts
func (_m *RskBridgeAdapterMock) GetMinimumLockTxValue(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetMinimumLockTxValue")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_GetMinimumLockTxValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMinimumLockTxValue'
type RskBridgeAdapterMock_GetMinimumLockTxValue_Call struct {
	*mock.Call
}

// GetMinimumLockTxValue is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RskBridgeAdapterMock_Expecter) GetMinimumLockTxValue(opts interface{}) *RskBridgeAdapterMock_GetMinimumLockTxValue_Call {
	return &RskBridgeAdapterMock_GetMinimumLockTxValue_Call{Call: _e.mock.On("GetMinimumLockTxValue", opts)}
}

func (_c *RskBridgeAdapterMock_GetMinimumLockTxValue_Call) Run(run func(opts *bind.CallOpts)) *RskBridgeAdapterMock_GetMinimumLockTxValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_GetMinimumLockTxValue_Call) Return(_a0 *big.Int, _a1 error) *RskBridgeAdapterMock_GetMinimumLockTxValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_GetMinimumLockTxValue_Call) RunAndReturn(run func(*bind.CallOpts) (*big.Int, error)) *RskBridgeAdapterMock_GetMinimumLockTxValue_Call {
	_c.Call.Return(run)
	return _c
}

// HasBtcBlockCoinbaseTransactionInformation provides a mock function with given fields: opts, blockHash
func (_m *RskBridgeAdapterMock) HasBtcBlockCoinbaseTransactionInformation(opts *bind.CallOpts, blockHash [32]byte) (bool, error) {
	ret := _m.Called(opts, blockHash)

	if len(ret) == 0 {
		panic("no return value specified for HasBtcBlockCoinbaseTransactionInformation")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (bool, error)); ok {
		return rf(opts, blockHash)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) bool); ok {
		r0 = rf(opts, blockHash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, blockHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasBtcBlockCoinbaseTransactionInformation'
type RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call struct {
	*mock.Call
}

// HasBtcBlockCoinbaseTransactionInformation is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - blockHash [32]byte
func (_e *RskBridgeAdapterMock_Expecter) HasBtcBlockCoinbaseTransactionInformation(opts interface{}, blockHash interface{}) *RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call {
	return &RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call{Call: _e.mock.On("HasBtcBlockCoinbaseTransactionInformation", opts, blockHash)}
}

func (_c *RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call) Run(run func(opts *bind.CallOpts, blockHash [32]byte)) *RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call) Return(_a0 bool, _a1 error) *RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (bool, error)) *RskBridgeAdapterMock_HasBtcBlockCoinbaseTransactionInformation_Call {
	_c.Call.Return(run)
	return _c
}

// IsBtcTxHashAlreadyProcessed provides a mock function with given fields: opts, hash
func (_m *RskBridgeAdapterMock) IsBtcTxHashAlreadyProcessed(opts *bind.CallOpts, hash string) (bool, error) {
	ret := _m.Called(opts, hash)

	if len(ret) == 0 {
		panic("no return value specified for IsBtcTxHashAlreadyProcessed")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, string) (bool, error)); ok {
		return rf(opts, hash)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, string) bool); ok {
		r0 = rf(opts, hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, string) error); ok {
		r1 = rf(opts, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsBtcTxHashAlreadyProcessed'
type RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call struct {
	*mock.Call
}

// IsBtcTxHashAlreadyProcessed is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - hash string
func (_e *RskBridgeAdapterMock_Expecter) IsBtcTxHashAlreadyProcessed(opts interface{}, hash interface{}) *RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call {
	return &RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call{Call: _e.mock.On("IsBtcTxHashAlreadyProcessed", opts, hash)}
}

func (_c *RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call) Run(run func(opts *bind.CallOpts, hash string)) *RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(string))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call) Return(_a0 bool, _a1 error) *RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call) RunAndReturn(run func(*bind.CallOpts, string) (bool, error)) *RskBridgeAdapterMock_IsBtcTxHashAlreadyProcessed_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterBtcCoinbaseTransaction provides a mock function with given fields: opts, btcTxSerialized, blockHash, pmtSerialized, witnessMerkleRoot, witnessReservedValue
func (_m *RskBridgeAdapterMock) RegisterBtcCoinbaseTransaction(opts *bind.TransactOpts, btcTxSerialized []byte, blockHash [32]byte, pmtSerialized []byte, witnessMerkleRoot [32]byte, witnessReservedValue [32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, btcTxSerialized, blockHash, pmtSerialized, witnessMerkleRoot, witnessReservedValue)

	if len(ret) == 0 {
		panic("no return value specified for RegisterBtcCoinbaseTransaction")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, [32]byte, []byte, [32]byte, [32]byte) (*types.Transaction, error)); ok {
		return rf(opts, btcTxSerialized, blockHash, pmtSerialized, witnessMerkleRoot, witnessReservedValue)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, [32]byte, []byte, [32]byte, [32]byte) *types.Transaction); ok {
		r0 = rf(opts, btcTxSerialized, blockHash, pmtSerialized, witnessMerkleRoot, witnessReservedValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, [32]byte, []byte, [32]byte, [32]byte) error); ok {
		r1 = rf(opts, btcTxSerialized, blockHash, pmtSerialized, witnessMerkleRoot, witnessReservedValue)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterBtcCoinbaseTransaction'
type RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call struct {
	*mock.Call
}

// RegisterBtcCoinbaseTransaction is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - btcTxSerialized []byte
//   - blockHash [32]byte
//   - pmtSerialized []byte
//   - witnessMerkleRoot [32]byte
//   - witnessReservedValue [32]byte
func (_e *RskBridgeAdapterMock_Expecter) RegisterBtcCoinbaseTransaction(opts interface{}, btcTxSerialized interface{}, blockHash interface{}, pmtSerialized interface{}, witnessMerkleRoot interface{}, witnessReservedValue interface{}) *RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call {
	return &RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call{Call: _e.mock.On("RegisterBtcCoinbaseTransaction", opts, btcTxSerialized, blockHash, pmtSerialized, witnessMerkleRoot, witnessReservedValue)}
}

func (_c *RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call) Run(run func(opts *bind.TransactOpts, btcTxSerialized []byte, blockHash [32]byte, pmtSerialized []byte, witnessMerkleRoot [32]byte, witnessReservedValue [32]byte)) *RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]byte), args[2].([32]byte), args[3].([]byte), args[4].([32]byte), args[5].([32]byte))
	})
	return _c
}

func (_c *RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call) Return(_a0 *types.Transaction, _a1 error) *RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call) RunAndReturn(run func(*bind.TransactOpts, []byte, [32]byte, []byte, [32]byte, [32]byte) (*types.Transaction, error)) *RskBridgeAdapterMock_RegisterBtcCoinbaseTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewRskBridgeAdapterMock creates a new instance of RskBridgeAdapterMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRskBridgeAdapterMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *RskBridgeAdapterMock {
	mock := &RskBridgeAdapterMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
