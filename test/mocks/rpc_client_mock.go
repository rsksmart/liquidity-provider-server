// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
	btcjson "github.com/btcsuite/btcd/btcjson"
	btcutil "github.com/btcsuite/btcd/btcutil"

	chainhash "github.com/btcsuite/btcd/chaincfg/chainhash"

	mock "github.com/stretchr/testify/mock"

	rpcclient "github.com/btcsuite/btcd/rpcclient"

	wire "github.com/btcsuite/btcd/wire"
)

// RpcClientMock is an autogenerated mock type for the rpcClient type
type RpcClientMock struct {
	mock.Mock
}

type RpcClientMock_Expecter struct {
	mock *mock.Mock
}

func (_m *RpcClientMock) EXPECT() *RpcClientMock_Expecter {
	return &RpcClientMock_Expecter{mock: &_m.Mock}
}

// CreateRawTransaction provides a mock function with given fields: inputs, amounts, lockTime
func (_m *RpcClientMock) CreateRawTransaction(inputs []btcjson.TransactionInput, amounts map[btcutil.Address]btcutil.Amount, lockTime *int64) (*wire.MsgTx, error) {
	ret := _m.Called(inputs, amounts, lockTime)

	if len(ret) == 0 {
		panic("no return value specified for CreateRawTransaction")
	}

	var r0 *wire.MsgTx
	var r1 error
	if rf, ok := ret.Get(0).(func([]btcjson.TransactionInput, map[btcutil.Address]btcutil.Amount, *int64) (*wire.MsgTx, error)); ok {
		return rf(inputs, amounts, lockTime)
	}
	if rf, ok := ret.Get(0).(func([]btcjson.TransactionInput, map[btcutil.Address]btcutil.Amount, *int64) *wire.MsgTx); ok {
		r0 = rf(inputs, amounts, lockTime)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wire.MsgTx)
		}
	}

	if rf, ok := ret.Get(1).(func([]btcjson.TransactionInput, map[btcutil.Address]btcutil.Amount, *int64) error); ok {
		r1 = rf(inputs, amounts, lockTime)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_CreateRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRawTransaction'
type RpcClientMock_CreateRawTransaction_Call struct {
	*mock.Call
}

// CreateRawTransaction is a helper method to define mock.On call
//   - inputs []btcjson.TransactionInput
//   - amounts map[btcutil.Address]btcutil.Amount
//   - lockTime *int64
func (_e *RpcClientMock_Expecter) CreateRawTransaction(inputs interface{}, amounts interface{}, lockTime interface{}) *RpcClientMock_CreateRawTransaction_Call {
	return &RpcClientMock_CreateRawTransaction_Call{Call: _e.mock.On("CreateRawTransaction", inputs, amounts, lockTime)}
}

func (_c *RpcClientMock_CreateRawTransaction_Call) Run(run func(inputs []btcjson.TransactionInput, amounts map[btcutil.Address]btcutil.Amount, lockTime *int64)) *RpcClientMock_CreateRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]btcjson.TransactionInput), args[1].(map[btcutil.Address]btcutil.Amount), args[2].(*int64))
	})
	return _c
}

func (_c *RpcClientMock_CreateRawTransaction_Call) Return(_a0 *wire.MsgTx, _a1 error) *RpcClientMock_CreateRawTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_CreateRawTransaction_Call) RunAndReturn(run func([]btcjson.TransactionInput, map[btcutil.Address]btcutil.Amount, *int64) (*wire.MsgTx, error)) *RpcClientMock_CreateRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWallet provides a mock function with given fields: name, opts
func (_m *RpcClientMock) CreateWallet(name string, opts ...rpcclient.CreateWalletOpt) (*btcjson.CreateWalletResult, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWallet")
	}

	var r0 *btcjson.CreateWalletResult
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...rpcclient.CreateWalletOpt) (*btcjson.CreateWalletResult, error)); ok {
		return rf(name, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...rpcclient.CreateWalletOpt) *btcjson.CreateWalletResult); ok {
		r0 = rf(name, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.CreateWalletResult)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...rpcclient.CreateWalletOpt) error); ok {
		r1 = rf(name, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_CreateWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWallet'
type RpcClientMock_CreateWallet_Call struct {
	*mock.Call
}

// CreateWallet is a helper method to define mock.On call
//   - name string
//   - opts ...rpcclient.CreateWalletOpt
func (_e *RpcClientMock_Expecter) CreateWallet(name interface{}, opts ...interface{}) *RpcClientMock_CreateWallet_Call {
	return &RpcClientMock_CreateWallet_Call{Call: _e.mock.On("CreateWallet",
		append([]interface{}{name}, opts...)...)}
}

func (_c *RpcClientMock_CreateWallet_Call) Run(run func(name string, opts ...rpcclient.CreateWalletOpt)) *RpcClientMock_CreateWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]rpcclient.CreateWalletOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(rpcclient.CreateWalletOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *RpcClientMock_CreateWallet_Call) Return(_a0 *btcjson.CreateWalletResult, _a1 error) *RpcClientMock_CreateWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_CreateWallet_Call) RunAndReturn(run func(string, ...rpcclient.CreateWalletOpt) (*btcjson.CreateWalletResult, error)) *RpcClientMock_CreateWallet_Call {
	_c.Call.Return(run)
	return _c
}

// Disconnect provides a mock function with given fields:
func (_m *RpcClientMock) Disconnect() {
	_m.Called()
}

// RpcClientMock_Disconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Disconnect'
type RpcClientMock_Disconnect_Call struct {
	*mock.Call
}

// Disconnect is a helper method to define mock.On call
func (_e *RpcClientMock_Expecter) Disconnect() *RpcClientMock_Disconnect_Call {
	return &RpcClientMock_Disconnect_Call{Call: _e.mock.On("Disconnect")}
}

func (_c *RpcClientMock_Disconnect_Call) Run(run func()) *RpcClientMock_Disconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RpcClientMock_Disconnect_Call) Return() *RpcClientMock_Disconnect_Call {
	_c.Call.Return()
	return _c
}

func (_c *RpcClientMock_Disconnect_Call) RunAndReturn(run func()) *RpcClientMock_Disconnect_Call {
	_c.Call.Return(run)
	return _c
}

// EstimateSmartFee provides a mock function with given fields: confTarget, mode
func (_m *RpcClientMock) EstimateSmartFee(confTarget int64, mode *btcjson.EstimateSmartFeeMode) (*btcjson.EstimateSmartFeeResult, error) {
	ret := _m.Called(confTarget, mode)

	if len(ret) == 0 {
		panic("no return value specified for EstimateSmartFee")
	}

	var r0 *btcjson.EstimateSmartFeeResult
	var r1 error
	if rf, ok := ret.Get(0).(func(int64, *btcjson.EstimateSmartFeeMode) (*btcjson.EstimateSmartFeeResult, error)); ok {
		return rf(confTarget, mode)
	}
	if rf, ok := ret.Get(0).(func(int64, *btcjson.EstimateSmartFeeMode) *btcjson.EstimateSmartFeeResult); ok {
		r0 = rf(confTarget, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.EstimateSmartFeeResult)
		}
	}

	if rf, ok := ret.Get(1).(func(int64, *btcjson.EstimateSmartFeeMode) error); ok {
		r1 = rf(confTarget, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_EstimateSmartFee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EstimateSmartFee'
type RpcClientMock_EstimateSmartFee_Call struct {
	*mock.Call
}

// EstimateSmartFee is a helper method to define mock.On call
//   - confTarget int64
//   - mode *btcjson.EstimateSmartFeeMode
func (_e *RpcClientMock_Expecter) EstimateSmartFee(confTarget interface{}, mode interface{}) *RpcClientMock_EstimateSmartFee_Call {
	return &RpcClientMock_EstimateSmartFee_Call{Call: _e.mock.On("EstimateSmartFee", confTarget, mode)}
}

func (_c *RpcClientMock_EstimateSmartFee_Call) Run(run func(confTarget int64, mode *btcjson.EstimateSmartFeeMode)) *RpcClientMock_EstimateSmartFee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(*btcjson.EstimateSmartFeeMode))
	})
	return _c
}

func (_c *RpcClientMock_EstimateSmartFee_Call) Return(_a0 *btcjson.EstimateSmartFeeResult, _a1 error) *RpcClientMock_EstimateSmartFee_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_EstimateSmartFee_Call) RunAndReturn(run func(int64, *btcjson.EstimateSmartFeeMode) (*btcjson.EstimateSmartFeeResult, error)) *RpcClientMock_EstimateSmartFee_Call {
	_c.Call.Return(run)
	return _c
}

// FundRawTransaction provides a mock function with given fields: tx, opts, isWitness
func (_m *RpcClientMock) FundRawTransaction(tx *wire.MsgTx, opts btcjson.FundRawTransactionOpts, isWitness *bool) (*btcjson.FundRawTransactionResult, error) {
	ret := _m.Called(tx, opts, isWitness)

	if len(ret) == 0 {
		panic("no return value specified for FundRawTransaction")
	}

	var r0 *btcjson.FundRawTransactionResult
	var r1 error
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, btcjson.FundRawTransactionOpts, *bool) (*btcjson.FundRawTransactionResult, error)); ok {
		return rf(tx, opts, isWitness)
	}
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, btcjson.FundRawTransactionOpts, *bool) *btcjson.FundRawTransactionResult); ok {
		r0 = rf(tx, opts, isWitness)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.FundRawTransactionResult)
		}
	}

	if rf, ok := ret.Get(1).(func(*wire.MsgTx, btcjson.FundRawTransactionOpts, *bool) error); ok {
		r1 = rf(tx, opts, isWitness)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_FundRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FundRawTransaction'
type RpcClientMock_FundRawTransaction_Call struct {
	*mock.Call
}

// FundRawTransaction is a helper method to define mock.On call
//   - tx *wire.MsgTx
//   - opts btcjson.FundRawTransactionOpts
//   - isWitness *bool
func (_e *RpcClientMock_Expecter) FundRawTransaction(tx interface{}, opts interface{}, isWitness interface{}) *RpcClientMock_FundRawTransaction_Call {
	return &RpcClientMock_FundRawTransaction_Call{Call: _e.mock.On("FundRawTransaction", tx, opts, isWitness)}
}

func (_c *RpcClientMock_FundRawTransaction_Call) Run(run func(tx *wire.MsgTx, opts btcjson.FundRawTransactionOpts, isWitness *bool)) *RpcClientMock_FundRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*wire.MsgTx), args[1].(btcjson.FundRawTransactionOpts), args[2].(*bool))
	})
	return _c
}

func (_c *RpcClientMock_FundRawTransaction_Call) Return(_a0 *btcjson.FundRawTransactionResult, _a1 error) *RpcClientMock_FundRawTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_FundRawTransaction_Call) RunAndReturn(run func(*wire.MsgTx, btcjson.FundRawTransactionOpts, *bool) (*btcjson.FundRawTransactionResult, error)) *RpcClientMock_FundRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddressInfo provides a mock function with given fields: address
func (_m *RpcClientMock) GetAddressInfo(address string) (*btcjson.GetAddressInfoResult, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAddressInfo")
	}

	var r0 *btcjson.GetAddressInfoResult
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*btcjson.GetAddressInfoResult, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) *btcjson.GetAddressInfoResult); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetAddressInfoResult)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_GetAddressInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddressInfo'
type RpcClientMock_GetAddressInfo_Call struct {
	*mock.Call
}

// GetAddressInfo is a helper method to define mock.On call
//   - address string
func (_e *RpcClientMock_Expecter) GetAddressInfo(address interface{}) *RpcClientMock_GetAddressInfo_Call {
	return &RpcClientMock_GetAddressInfo_Call{Call: _e.mock.On("GetAddressInfo", address)}
}

func (_c *RpcClientMock_GetAddressInfo_Call) Run(run func(address string)) *RpcClientMock_GetAddressInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *RpcClientMock_GetAddressInfo_Call) Return(_a0 *btcjson.GetAddressInfoResult, _a1 error) *RpcClientMock_GetAddressInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_GetAddressInfo_Call) RunAndReturn(run func(string) (*btcjson.GetAddressInfoResult, error)) *RpcClientMock_GetAddressInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlock provides a mock function with given fields: blockHash
func (_m *RpcClientMock) GetBlock(blockHash *chainhash.Hash) (*wire.MsgBlock, error) {
	ret := _m.Called(blockHash)

	if len(ret) == 0 {
		panic("no return value specified for GetBlock")
	}

	var r0 *wire.MsgBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*wire.MsgBlock, error)); ok {
		return rf(blockHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *wire.MsgBlock); ok {
		r0 = rf(blockHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wire.MsgBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(blockHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_GetBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlock'
type RpcClientMock_GetBlock_Call struct {
	*mock.Call
}

// GetBlock is a helper method to define mock.On call
//   - blockHash *chainhash.Hash
func (_e *RpcClientMock_Expecter) GetBlock(blockHash interface{}) *RpcClientMock_GetBlock_Call {
	return &RpcClientMock_GetBlock_Call{Call: _e.mock.On("GetBlock", blockHash)}
}

func (_c *RpcClientMock_GetBlock_Call) Run(run func(blockHash *chainhash.Hash)) *RpcClientMock_GetBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *RpcClientMock_GetBlock_Call) Return(_a0 *wire.MsgBlock, _a1 error) *RpcClientMock_GetBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_GetBlock_Call) RunAndReturn(run func(*chainhash.Hash) (*wire.MsgBlock, error)) *RpcClientMock_GetBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockChainInfo provides a mock function with given fields:
func (_m *RpcClientMock) GetBlockChainInfo() (*btcjson.GetBlockChainInfoResult, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBlockChainInfo")
	}

	var r0 *btcjson.GetBlockChainInfoResult
	var r1 error
	if rf, ok := ret.Get(0).(func() (*btcjson.GetBlockChainInfoResult, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *btcjson.GetBlockChainInfoResult); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetBlockChainInfoResult)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_GetBlockChainInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockChainInfo'
type RpcClientMock_GetBlockChainInfo_Call struct {
	*mock.Call
}

// GetBlockChainInfo is a helper method to define mock.On call
func (_e *RpcClientMock_Expecter) GetBlockChainInfo() *RpcClientMock_GetBlockChainInfo_Call {
	return &RpcClientMock_GetBlockChainInfo_Call{Call: _e.mock.On("GetBlockChainInfo")}
}

func (_c *RpcClientMock_GetBlockChainInfo_Call) Run(run func()) *RpcClientMock_GetBlockChainInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RpcClientMock_GetBlockChainInfo_Call) Return(_a0 *btcjson.GetBlockChainInfoResult, _a1 error) *RpcClientMock_GetBlockChainInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_GetBlockChainInfo_Call) RunAndReturn(run func() (*btcjson.GetBlockChainInfoResult, error)) *RpcClientMock_GetBlockChainInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockVerbose provides a mock function with given fields: blockHash
func (_m *RpcClientMock) GetBlockVerbose(blockHash *chainhash.Hash) (*btcjson.GetBlockVerboseResult, error) {
	ret := _m.Called(blockHash)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockVerbose")
	}

	var r0 *btcjson.GetBlockVerboseResult
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*btcjson.GetBlockVerboseResult, error)); ok {
		return rf(blockHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *btcjson.GetBlockVerboseResult); ok {
		r0 = rf(blockHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetBlockVerboseResult)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(blockHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_GetBlockVerbose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockVerbose'
type RpcClientMock_GetBlockVerbose_Call struct {
	*mock.Call
}

// GetBlockVerbose is a helper method to define mock.On call
//   - blockHash *chainhash.Hash
func (_e *RpcClientMock_Expecter) GetBlockVerbose(blockHash interface{}) *RpcClientMock_GetBlockVerbose_Call {
	return &RpcClientMock_GetBlockVerbose_Call{Call: _e.mock.On("GetBlockVerbose", blockHash)}
}

func (_c *RpcClientMock_GetBlockVerbose_Call) Run(run func(blockHash *chainhash.Hash)) *RpcClientMock_GetBlockVerbose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *RpcClientMock_GetBlockVerbose_Call) Return(_a0 *btcjson.GetBlockVerboseResult, _a1 error) *RpcClientMock_GetBlockVerbose_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_GetBlockVerbose_Call) RunAndReturn(run func(*chainhash.Hash) (*btcjson.GetBlockVerboseResult, error)) *RpcClientMock_GetBlockVerbose_Call {
	_c.Call.Return(run)
	return _c
}

// GetRawTransaction provides a mock function with given fields: txHash
func (_m *RpcClientMock) GetRawTransaction(txHash *chainhash.Hash) (*btcutil.Tx, error) {
	ret := _m.Called(txHash)

	if len(ret) == 0 {
		panic("no return value specified for GetRawTransaction")
	}

	var r0 *btcutil.Tx
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*btcutil.Tx, error)); ok {
		return rf(txHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *btcutil.Tx); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcutil.Tx)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_GetRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRawTransaction'
type RpcClientMock_GetRawTransaction_Call struct {
	*mock.Call
}

// GetRawTransaction is a helper method to define mock.On call
//   - txHash *chainhash.Hash
func (_e *RpcClientMock_Expecter) GetRawTransaction(txHash interface{}) *RpcClientMock_GetRawTransaction_Call {
	return &RpcClientMock_GetRawTransaction_Call{Call: _e.mock.On("GetRawTransaction", txHash)}
}

func (_c *RpcClientMock_GetRawTransaction_Call) Run(run func(txHash *chainhash.Hash)) *RpcClientMock_GetRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *RpcClientMock_GetRawTransaction_Call) Return(_a0 *btcutil.Tx, _a1 error) *RpcClientMock_GetRawTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_GetRawTransaction_Call) RunAndReturn(run func(*chainhash.Hash) (*btcutil.Tx, error)) *RpcClientMock_GetRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// GetRawTransactionVerbose provides a mock function with given fields: txHash
func (_m *RpcClientMock) GetRawTransactionVerbose(txHash *chainhash.Hash) (*btcjson.TxRawResult, error) {
	ret := _m.Called(txHash)

	if len(ret) == 0 {
		panic("no return value specified for GetRawTransactionVerbose")
	}

	var r0 *btcjson.TxRawResult
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*btcjson.TxRawResult, error)); ok {
		return rf(txHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *btcjson.TxRawResult); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.TxRawResult)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_GetRawTransactionVerbose_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRawTransactionVerbose'
type RpcClientMock_GetRawTransactionVerbose_Call struct {
	*mock.Call
}

// GetRawTransactionVerbose is a helper method to define mock.On call
//   - txHash *chainhash.Hash
func (_e *RpcClientMock_Expecter) GetRawTransactionVerbose(txHash interface{}) *RpcClientMock_GetRawTransactionVerbose_Call {
	return &RpcClientMock_GetRawTransactionVerbose_Call{Call: _e.mock.On("GetRawTransactionVerbose", txHash)}
}

func (_c *RpcClientMock_GetRawTransactionVerbose_Call) Run(run func(txHash *chainhash.Hash)) *RpcClientMock_GetRawTransactionVerbose_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *RpcClientMock_GetRawTransactionVerbose_Call) Return(_a0 *btcjson.TxRawResult, _a1 error) *RpcClientMock_GetRawTransactionVerbose_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_GetRawTransactionVerbose_Call) RunAndReturn(run func(*chainhash.Hash) (*btcjson.TxRawResult, error)) *RpcClientMock_GetRawTransactionVerbose_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransaction provides a mock function with given fields: txHash
func (_m *RpcClientMock) GetTransaction(txHash *chainhash.Hash) (*btcjson.GetTransactionResult, error) {
	ret := _m.Called(txHash)

	if len(ret) == 0 {
		panic("no return value specified for GetTransaction")
	}

	var r0 *btcjson.GetTransactionResult
	var r1 error
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) (*btcjson.GetTransactionResult, error)); ok {
		return rf(txHash)
	}
	if rf, ok := ret.Get(0).(func(*chainhash.Hash) *btcjson.GetTransactionResult); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetTransactionResult)
		}
	}

	if rf, ok := ret.Get(1).(func(*chainhash.Hash) error); ok {
		r1 = rf(txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_GetTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransaction'
type RpcClientMock_GetTransaction_Call struct {
	*mock.Call
}

// GetTransaction is a helper method to define mock.On call
//   - txHash *chainhash.Hash
func (_e *RpcClientMock_Expecter) GetTransaction(txHash interface{}) *RpcClientMock_GetTransaction_Call {
	return &RpcClientMock_GetTransaction_Call{Call: _e.mock.On("GetTransaction", txHash)}
}

func (_c *RpcClientMock_GetTransaction_Call) Run(run func(txHash *chainhash.Hash)) *RpcClientMock_GetTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*chainhash.Hash))
	})
	return _c
}

func (_c *RpcClientMock_GetTransaction_Call) Return(_a0 *btcjson.GetTransactionResult, _a1 error) *RpcClientMock_GetTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_GetTransaction_Call) RunAndReturn(run func(*chainhash.Hash) (*btcjson.GetTransactionResult, error)) *RpcClientMock_GetTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// GetWalletInfo provides a mock function with given fields:
func (_m *RpcClientMock) GetWalletInfo() (*btcjson.GetWalletInfoResult, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetWalletInfo")
	}

	var r0 *btcjson.GetWalletInfoResult
	var r1 error
	if rf, ok := ret.Get(0).(func() (*btcjson.GetWalletInfoResult, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *btcjson.GetWalletInfoResult); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.GetWalletInfoResult)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_GetWalletInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWalletInfo'
type RpcClientMock_GetWalletInfo_Call struct {
	*mock.Call
}

// GetWalletInfo is a helper method to define mock.On call
func (_e *RpcClientMock_Expecter) GetWalletInfo() *RpcClientMock_GetWalletInfo_Call {
	return &RpcClientMock_GetWalletInfo_Call{Call: _e.mock.On("GetWalletInfo")}
}

func (_c *RpcClientMock_GetWalletInfo_Call) Run(run func()) *RpcClientMock_GetWalletInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RpcClientMock_GetWalletInfo_Call) Return(_a0 *btcjson.GetWalletInfoResult, _a1 error) *RpcClientMock_GetWalletInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_GetWalletInfo_Call) RunAndReturn(run func() (*btcjson.GetWalletInfoResult, error)) *RpcClientMock_GetWalletInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ImportAddressRescan provides a mock function with given fields: address, account, rescan
func (_m *RpcClientMock) ImportAddressRescan(address string, account string, rescan bool) error {
	ret := _m.Called(address, account, rescan)

	if len(ret) == 0 {
		panic("no return value specified for ImportAddressRescan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool) error); ok {
		r0 = rf(address, account, rescan)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RpcClientMock_ImportAddressRescan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportAddressRescan'
type RpcClientMock_ImportAddressRescan_Call struct {
	*mock.Call
}

// ImportAddressRescan is a helper method to define mock.On call
//   - address string
//   - account string
//   - rescan bool
func (_e *RpcClientMock_Expecter) ImportAddressRescan(address interface{}, account interface{}, rescan interface{}) *RpcClientMock_ImportAddressRescan_Call {
	return &RpcClientMock_ImportAddressRescan_Call{Call: _e.mock.On("ImportAddressRescan", address, account, rescan)}
}

func (_c *RpcClientMock_ImportAddressRescan_Call) Run(run func(address string, account string, rescan bool)) *RpcClientMock_ImportAddressRescan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *RpcClientMock_ImportAddressRescan_Call) Return(_a0 error) *RpcClientMock_ImportAddressRescan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RpcClientMock_ImportAddressRescan_Call) RunAndReturn(run func(string, string, bool) error) *RpcClientMock_ImportAddressRescan_Call {
	_c.Call.Return(run)
	return _c
}

// ImportPubKeyRescan provides a mock function with given fields: pubKey, rescan
func (_m *RpcClientMock) ImportPubKeyRescan(pubKey string, rescan bool) error {
	ret := _m.Called(pubKey, rescan)

	if len(ret) == 0 {
		panic("no return value specified for ImportPubKeyRescan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, bool) error); ok {
		r0 = rf(pubKey, rescan)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RpcClientMock_ImportPubKeyRescan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportPubKeyRescan'
type RpcClientMock_ImportPubKeyRescan_Call struct {
	*mock.Call
}

// ImportPubKeyRescan is a helper method to define mock.On call
//   - pubKey string
//   - rescan bool
func (_e *RpcClientMock_Expecter) ImportPubKeyRescan(pubKey interface{}, rescan interface{}) *RpcClientMock_ImportPubKeyRescan_Call {
	return &RpcClientMock_ImportPubKeyRescan_Call{Call: _e.mock.On("ImportPubKeyRescan", pubKey, rescan)}
}

func (_c *RpcClientMock_ImportPubKeyRescan_Call) Run(run func(pubKey string, rescan bool)) *RpcClientMock_ImportPubKeyRescan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(bool))
	})
	return _c
}

func (_c *RpcClientMock_ImportPubKeyRescan_Call) Return(_a0 error) *RpcClientMock_ImportPubKeyRescan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RpcClientMock_ImportPubKeyRescan_Call) RunAndReturn(run func(string, bool) error) *RpcClientMock_ImportPubKeyRescan_Call {
	_c.Call.Return(run)
	return _c
}

// ListUnspent provides a mock function with given fields:
func (_m *RpcClientMock) ListUnspent() ([]btcjson.ListUnspentResult, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ListUnspent")
	}

	var r0 []btcjson.ListUnspentResult
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]btcjson.ListUnspentResult, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []btcjson.ListUnspentResult); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]btcjson.ListUnspentResult)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_ListUnspent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUnspent'
type RpcClientMock_ListUnspent_Call struct {
	*mock.Call
}

// ListUnspent is a helper method to define mock.On call
func (_e *RpcClientMock_Expecter) ListUnspent() *RpcClientMock_ListUnspent_Call {
	return &RpcClientMock_ListUnspent_Call{Call: _e.mock.On("ListUnspent")}
}

func (_c *RpcClientMock_ListUnspent_Call) Run(run func()) *RpcClientMock_ListUnspent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RpcClientMock_ListUnspent_Call) Return(_a0 []btcjson.ListUnspentResult, _a1 error) *RpcClientMock_ListUnspent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_ListUnspent_Call) RunAndReturn(run func() ([]btcjson.ListUnspentResult, error)) *RpcClientMock_ListUnspent_Call {
	_c.Call.Return(run)
	return _c
}

// ListUnspentMinMaxAddresses provides a mock function with given fields: minConf, maxConf, addrs
func (_m *RpcClientMock) ListUnspentMinMaxAddresses(minConf int, maxConf int, addrs []btcutil.Address) ([]btcjson.ListUnspentResult, error) {
	ret := _m.Called(minConf, maxConf, addrs)

	if len(ret) == 0 {
		panic("no return value specified for ListUnspentMinMaxAddresses")
	}

	var r0 []btcjson.ListUnspentResult
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, []btcutil.Address) ([]btcjson.ListUnspentResult, error)); ok {
		return rf(minConf, maxConf, addrs)
	}
	if rf, ok := ret.Get(0).(func(int, int, []btcutil.Address) []btcjson.ListUnspentResult); ok {
		r0 = rf(minConf, maxConf, addrs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]btcjson.ListUnspentResult)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, []btcutil.Address) error); ok {
		r1 = rf(minConf, maxConf, addrs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_ListUnspentMinMaxAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUnspentMinMaxAddresses'
type RpcClientMock_ListUnspentMinMaxAddresses_Call struct {
	*mock.Call
}

// ListUnspentMinMaxAddresses is a helper method to define mock.On call
//   - minConf int
//   - maxConf int
//   - addrs []btcutil.Address
func (_e *RpcClientMock_Expecter) ListUnspentMinMaxAddresses(minConf interface{}, maxConf interface{}, addrs interface{}) *RpcClientMock_ListUnspentMinMaxAddresses_Call {
	return &RpcClientMock_ListUnspentMinMaxAddresses_Call{Call: _e.mock.On("ListUnspentMinMaxAddresses", minConf, maxConf, addrs)}
}

func (_c *RpcClientMock_ListUnspentMinMaxAddresses_Call) Run(run func(minConf int, maxConf int, addrs []btcutil.Address)) *RpcClientMock_ListUnspentMinMaxAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int), args[2].([]btcutil.Address))
	})
	return _c
}

func (_c *RpcClientMock_ListUnspentMinMaxAddresses_Call) Return(_a0 []btcjson.ListUnspentResult, _a1 error) *RpcClientMock_ListUnspentMinMaxAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_ListUnspentMinMaxAddresses_Call) RunAndReturn(run func(int, int, []btcutil.Address) ([]btcjson.ListUnspentResult, error)) *RpcClientMock_ListUnspentMinMaxAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// LoadWallet provides a mock function with given fields: walletName
func (_m *RpcClientMock) LoadWallet(walletName string) (*btcjson.LoadWalletResult, error) {
	ret := _m.Called(walletName)

	if len(ret) == 0 {
		panic("no return value specified for LoadWallet")
	}

	var r0 *btcjson.LoadWalletResult
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*btcjson.LoadWalletResult, error)); ok {
		return rf(walletName)
	}
	if rf, ok := ret.Get(0).(func(string) *btcjson.LoadWalletResult); ok {
		r0 = rf(walletName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.LoadWalletResult)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(walletName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_LoadWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadWallet'
type RpcClientMock_LoadWallet_Call struct {
	*mock.Call
}

// LoadWallet is a helper method to define mock.On call
//   - walletName string
func (_e *RpcClientMock_Expecter) LoadWallet(walletName interface{}) *RpcClientMock_LoadWallet_Call {
	return &RpcClientMock_LoadWallet_Call{Call: _e.mock.On("LoadWallet", walletName)}
}

func (_c *RpcClientMock_LoadWallet_Call) Run(run func(walletName string)) *RpcClientMock_LoadWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *RpcClientMock_LoadWallet_Call) Return(_a0 *btcjson.LoadWalletResult, _a1 error) *RpcClientMock_LoadWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_LoadWallet_Call) RunAndReturn(run func(string) (*btcjson.LoadWalletResult, error)) *RpcClientMock_LoadWallet_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function with given fields:
func (_m *RpcClientMock) Ping() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RpcClientMock_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type RpcClientMock_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
func (_e *RpcClientMock_Expecter) Ping() *RpcClientMock_Ping_Call {
	return &RpcClientMock_Ping_Call{Call: _e.mock.On("Ping")}
}

func (_c *RpcClientMock_Ping_Call) Run(run func()) *RpcClientMock_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RpcClientMock_Ping_Call) Return(_a0 error) *RpcClientMock_Ping_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RpcClientMock_Ping_Call) RunAndReturn(run func() error) *RpcClientMock_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// SendRawTransaction provides a mock function with given fields: tx, allowHighFees
func (_m *RpcClientMock) SendRawTransaction(tx *wire.MsgTx, allowHighFees bool) (*chainhash.Hash, error) {
	ret := _m.Called(tx, allowHighFees)

	if len(ret) == 0 {
		panic("no return value specified for SendRawTransaction")
	}

	var r0 *chainhash.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, bool) (*chainhash.Hash, error)); ok {
		return rf(tx, allowHighFees)
	}
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, bool) *chainhash.Hash); ok {
		r0 = rf(tx, allowHighFees)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chainhash.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(*wire.MsgTx, bool) error); ok {
		r1 = rf(tx, allowHighFees)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_SendRawTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendRawTransaction'
type RpcClientMock_SendRawTransaction_Call struct {
	*mock.Call
}

// SendRawTransaction is a helper method to define mock.On call
//   - tx *wire.MsgTx
//   - allowHighFees bool
func (_e *RpcClientMock_Expecter) SendRawTransaction(tx interface{}, allowHighFees interface{}) *RpcClientMock_SendRawTransaction_Call {
	return &RpcClientMock_SendRawTransaction_Call{Call: _e.mock.On("SendRawTransaction", tx, allowHighFees)}
}

func (_c *RpcClientMock_SendRawTransaction_Call) Run(run func(tx *wire.MsgTx, allowHighFees bool)) *RpcClientMock_SendRawTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*wire.MsgTx), args[1].(bool))
	})
	return _c
}

func (_c *RpcClientMock_SendRawTransaction_Call) Return(_a0 *chainhash.Hash, _a1 error) *RpcClientMock_SendRawTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_SendRawTransaction_Call) RunAndReturn(run func(*wire.MsgTx, bool) (*chainhash.Hash, error)) *RpcClientMock_SendRawTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// SignRawTransaction3 provides a mock function with given fields: tx, inputs, privKeysWIF
func (_m *RpcClientMock) SignRawTransaction3(tx *wire.MsgTx, inputs []btcjson.RawTxInput, privKeysWIF []string) (*wire.MsgTx, bool, error) {
	ret := _m.Called(tx, inputs, privKeysWIF)

	if len(ret) == 0 {
		panic("no return value specified for SignRawTransaction3")
	}

	var r0 *wire.MsgTx
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, []btcjson.RawTxInput, []string) (*wire.MsgTx, bool, error)); ok {
		return rf(tx, inputs, privKeysWIF)
	}
	if rf, ok := ret.Get(0).(func(*wire.MsgTx, []btcjson.RawTxInput, []string) *wire.MsgTx); ok {
		r0 = rf(tx, inputs, privKeysWIF)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wire.MsgTx)
		}
	}

	if rf, ok := ret.Get(1).(func(*wire.MsgTx, []btcjson.RawTxInput, []string) bool); ok {
		r1 = rf(tx, inputs, privKeysWIF)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(*wire.MsgTx, []btcjson.RawTxInput, []string) error); ok {
		r2 = rf(tx, inputs, privKeysWIF)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RpcClientMock_SignRawTransaction3_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignRawTransaction3'
type RpcClientMock_SignRawTransaction3_Call struct {
	*mock.Call
}

// SignRawTransaction3 is a helper method to define mock.On call
//   - tx *wire.MsgTx
//   - inputs []btcjson.RawTxInput
//   - privKeysWIF []string
func (_e *RpcClientMock_Expecter) SignRawTransaction3(tx interface{}, inputs interface{}, privKeysWIF interface{}) *RpcClientMock_SignRawTransaction3_Call {
	return &RpcClientMock_SignRawTransaction3_Call{Call: _e.mock.On("SignRawTransaction3", tx, inputs, privKeysWIF)}
}

func (_c *RpcClientMock_SignRawTransaction3_Call) Run(run func(tx *wire.MsgTx, inputs []btcjson.RawTxInput, privKeysWIF []string)) *RpcClientMock_SignRawTransaction3_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*wire.MsgTx), args[1].([]btcjson.RawTxInput), args[2].([]string))
	})
	return _c
}

func (_c *RpcClientMock_SignRawTransaction3_Call) Return(_a0 *wire.MsgTx, _a1 bool, _a2 error) *RpcClientMock_SignRawTransaction3_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RpcClientMock_SignRawTransaction3_Call) RunAndReturn(run func(*wire.MsgTx, []btcjson.RawTxInput, []string) (*wire.MsgTx, bool, error)) *RpcClientMock_SignRawTransaction3_Call {
	_c.Call.Return(run)
	return _c
}

// SignRawTransactionWithWallet provides a mock function with given fields: tx
func (_m *RpcClientMock) SignRawTransactionWithWallet(tx *wire.MsgTx) (*wire.MsgTx, bool, error) {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for SignRawTransactionWithWallet")
	}

	var r0 *wire.MsgTx
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(*wire.MsgTx) (*wire.MsgTx, bool, error)); ok {
		return rf(tx)
	}
	if rf, ok := ret.Get(0).(func(*wire.MsgTx) *wire.MsgTx); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wire.MsgTx)
		}
	}

	if rf, ok := ret.Get(1).(func(*wire.MsgTx) bool); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(*wire.MsgTx) error); ok {
		r2 = rf(tx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RpcClientMock_SignRawTransactionWithWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignRawTransactionWithWallet'
type RpcClientMock_SignRawTransactionWithWallet_Call struct {
	*mock.Call
}

// SignRawTransactionWithWallet is a helper method to define mock.On call
//   - tx *wire.MsgTx
func (_e *RpcClientMock_Expecter) SignRawTransactionWithWallet(tx interface{}) *RpcClientMock_SignRawTransactionWithWallet_Call {
	return &RpcClientMock_SignRawTransactionWithWallet_Call{Call: _e.mock.On("SignRawTransactionWithWallet", tx)}
}

func (_c *RpcClientMock_SignRawTransactionWithWallet_Call) Run(run func(tx *wire.MsgTx)) *RpcClientMock_SignRawTransactionWithWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*wire.MsgTx))
	})
	return _c
}

func (_c *RpcClientMock_SignRawTransactionWithWallet_Call) Return(_a0 *wire.MsgTx, _a1 bool, _a2 error) *RpcClientMock_SignRawTransactionWithWallet_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RpcClientMock_SignRawTransactionWithWallet_Call) RunAndReturn(run func(*wire.MsgTx) (*wire.MsgTx, bool, error)) *RpcClientMock_SignRawTransactionWithWallet_Call {
	_c.Call.Return(run)
	return _c
}

// WalletCreateFundedPsbt provides a mock function with given fields: inputs, outputs, locktime, options, bip32Derivs
func (_m *RpcClientMock) WalletCreateFundedPsbt(inputs []btcjson.PsbtInput, outputs []btcjson.PsbtOutput, locktime *uint32, options *btcjson.WalletCreateFundedPsbtOpts, bip32Derivs *bool) (*btcjson.WalletCreateFundedPsbtResult, error) {
	ret := _m.Called(inputs, outputs, locktime, options, bip32Derivs)

	if len(ret) == 0 {
		panic("no return value specified for WalletCreateFundedPsbt")
	}

	var r0 *btcjson.WalletCreateFundedPsbtResult
	var r1 error
	if rf, ok := ret.Get(0).(func([]btcjson.PsbtInput, []btcjson.PsbtOutput, *uint32, *btcjson.WalletCreateFundedPsbtOpts, *bool) (*btcjson.WalletCreateFundedPsbtResult, error)); ok {
		return rf(inputs, outputs, locktime, options, bip32Derivs)
	}
	if rf, ok := ret.Get(0).(func([]btcjson.PsbtInput, []btcjson.PsbtOutput, *uint32, *btcjson.WalletCreateFundedPsbtOpts, *bool) *btcjson.WalletCreateFundedPsbtResult); ok {
		r0 = rf(inputs, outputs, locktime, options, bip32Derivs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcjson.WalletCreateFundedPsbtResult)
		}
	}

	if rf, ok := ret.Get(1).(func([]btcjson.PsbtInput, []btcjson.PsbtOutput, *uint32, *btcjson.WalletCreateFundedPsbtOpts, *bool) error); ok {
		r1 = rf(inputs, outputs, locktime, options, bip32Derivs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RpcClientMock_WalletCreateFundedPsbt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletCreateFundedPsbt'
type RpcClientMock_WalletCreateFundedPsbt_Call struct {
	*mock.Call
}

// WalletCreateFundedPsbt is a helper method to define mock.On call
//   - inputs []btcjson.PsbtInput
//   - outputs []btcjson.PsbtOutput
//   - locktime *uint32
//   - options *btcjson.WalletCreateFundedPsbtOpts
//   - bip32Derivs *bool
func (_e *RpcClientMock_Expecter) WalletCreateFundedPsbt(inputs interface{}, outputs interface{}, locktime interface{}, options interface{}, bip32Derivs interface{}) *RpcClientMock_WalletCreateFundedPsbt_Call {
	return &RpcClientMock_WalletCreateFundedPsbt_Call{Call: _e.mock.On("WalletCreateFundedPsbt", inputs, outputs, locktime, options, bip32Derivs)}
}

func (_c *RpcClientMock_WalletCreateFundedPsbt_Call) Run(run func(inputs []btcjson.PsbtInput, outputs []btcjson.PsbtOutput, locktime *uint32, options *btcjson.WalletCreateFundedPsbtOpts, bip32Derivs *bool)) *RpcClientMock_WalletCreateFundedPsbt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]btcjson.PsbtInput), args[1].([]btcjson.PsbtOutput), args[2].(*uint32), args[3].(*btcjson.WalletCreateFundedPsbtOpts), args[4].(*bool))
	})
	return _c
}

func (_c *RpcClientMock_WalletCreateFundedPsbt_Call) Return(_a0 *btcjson.WalletCreateFundedPsbtResult, _a1 error) *RpcClientMock_WalletCreateFundedPsbt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RpcClientMock_WalletCreateFundedPsbt_Call) RunAndReturn(run func([]btcjson.PsbtInput, []btcjson.PsbtOutput, *uint32, *btcjson.WalletCreateFundedPsbtOpts, *bool) (*btcjson.WalletCreateFundedPsbtResult, error)) *RpcClientMock_WalletCreateFundedPsbt_Call {
	_c.Call.Return(run)
	return _c
}

// WalletPassphrase provides a mock function with given fields: passphrase, timeoutSecs
func (_m *RpcClientMock) WalletPassphrase(passphrase string, timeoutSecs int64) error {
	ret := _m.Called(passphrase, timeoutSecs)

	if len(ret) == 0 {
		panic("no return value specified for WalletPassphrase")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int64) error); ok {
		r0 = rf(passphrase, timeoutSecs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RpcClientMock_WalletPassphrase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletPassphrase'
type RpcClientMock_WalletPassphrase_Call struct {
	*mock.Call
}

// WalletPassphrase is a helper method to define mock.On call
//   - passphrase string
//   - timeoutSecs int64
func (_e *RpcClientMock_Expecter) WalletPassphrase(passphrase interface{}, timeoutSecs interface{}) *RpcClientMock_WalletPassphrase_Call {
	return &RpcClientMock_WalletPassphrase_Call{Call: _e.mock.On("WalletPassphrase", passphrase, timeoutSecs)}
}

func (_c *RpcClientMock_WalletPassphrase_Call) Run(run func(passphrase string, timeoutSecs int64)) *RpcClientMock_WalletPassphrase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64))
	})
	return _c
}

func (_c *RpcClientMock_WalletPassphrase_Call) Return(_a0 error) *RpcClientMock_WalletPassphrase_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RpcClientMock_WalletPassphrase_Call) RunAndReturn(run func(string, int64) error) *RpcClientMock_WalletPassphrase_Call {
	_c.Call.Return(run)
	return _c
}

// NewRpcClientMock creates a new instance of RpcClientMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRpcClientMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *RpcClientMock {
	mock := &RpcClientMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
