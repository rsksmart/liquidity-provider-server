// Code generated by mockery v2.53.0. DO NOT EDIT.

package mocks

import (
	context "context"

	blockchain "github.com/rsksmart/liquidity-provider-server/internal/entities/blockchain"

	entities "github.com/rsksmart/liquidity-provider-server/internal/entities"

	liquidity_provider "github.com/rsksmart/liquidity-provider-server/internal/entities/liquidity_provider"

	mock "github.com/stretchr/testify/mock"

	penalization "github.com/rsksmart/liquidity-provider-server/internal/entities/penalization"

	quote "github.com/rsksmart/liquidity-provider-server/internal/entities/quote"
)

// LiquidityBridgeContractMock is an autogenerated mock type for the LiquidityBridgeContract type
type LiquidityBridgeContractMock struct {
	mock.Mock
}

type LiquidityBridgeContractMock_Expecter struct {
	mock *mock.Mock
}

func (_m *LiquidityBridgeContractMock) EXPECT() *LiquidityBridgeContractMock_Expecter {
	return &LiquidityBridgeContractMock_Expecter{mock: &_m.Mock}
}

// AddCollateral provides a mock function with given fields: amount
func (_m *LiquidityBridgeContractMock) AddCollateral(amount *entities.Wei) error {
	ret := _m.Called(amount)

	if len(ret) == 0 {
		panic("no return value specified for AddCollateral")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*entities.Wei) error); ok {
		r0 = rf(amount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiquidityBridgeContractMock_AddCollateral_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCollateral'
type LiquidityBridgeContractMock_AddCollateral_Call struct {
	*mock.Call
}

// AddCollateral is a helper method to define mock.On call
//   - amount *entities.Wei
func (_e *LiquidityBridgeContractMock_Expecter) AddCollateral(amount interface{}) *LiquidityBridgeContractMock_AddCollateral_Call {
	return &LiquidityBridgeContractMock_AddCollateral_Call{Call: _e.mock.On("AddCollateral", amount)}
}

func (_c *LiquidityBridgeContractMock_AddCollateral_Call) Run(run func(amount *entities.Wei)) *LiquidityBridgeContractMock_AddCollateral_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*entities.Wei))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_AddCollateral_Call) Return(_a0 error) *LiquidityBridgeContractMock_AddCollateral_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiquidityBridgeContractMock_AddCollateral_Call) RunAndReturn(run func(*entities.Wei) error) *LiquidityBridgeContractMock_AddCollateral_Call {
	_c.Call.Return(run)
	return _c
}

// AddPegoutCollateral provides a mock function with given fields: amount
func (_m *LiquidityBridgeContractMock) AddPegoutCollateral(amount *entities.Wei) error {
	ret := _m.Called(amount)

	if len(ret) == 0 {
		panic("no return value specified for AddPegoutCollateral")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*entities.Wei) error); ok {
		r0 = rf(amount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiquidityBridgeContractMock_AddPegoutCollateral_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPegoutCollateral'
type LiquidityBridgeContractMock_AddPegoutCollateral_Call struct {
	*mock.Call
}

// AddPegoutCollateral is a helper method to define mock.On call
//   - amount *entities.Wei
func (_e *LiquidityBridgeContractMock_Expecter) AddPegoutCollateral(amount interface{}) *LiquidityBridgeContractMock_AddPegoutCollateral_Call {
	return &LiquidityBridgeContractMock_AddPegoutCollateral_Call{Call: _e.mock.On("AddPegoutCollateral", amount)}
}

func (_c *LiquidityBridgeContractMock_AddPegoutCollateral_Call) Run(run func(amount *entities.Wei)) *LiquidityBridgeContractMock_AddPegoutCollateral_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*entities.Wei))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_AddPegoutCollateral_Call) Return(_a0 error) *LiquidityBridgeContractMock_AddPegoutCollateral_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiquidityBridgeContractMock_AddPegoutCollateral_Call) RunAndReturn(run func(*entities.Wei) error) *LiquidityBridgeContractMock_AddPegoutCollateral_Call {
	_c.Call.Return(run)
	return _c
}

// CallForUser provides a mock function with given fields: txConfig, peginQuote
func (_m *LiquidityBridgeContractMock) CallForUser(txConfig blockchain.TransactionConfig, peginQuote quote.PeginQuote) (blockchain.TransactionReceipt, error) {
	ret := _m.Called(txConfig, peginQuote)

	if len(ret) == 0 {
		panic("no return value specified for CallForUser")
	}

	var r0 blockchain.TransactionReceipt
	var r1 error
	if rf, ok := ret.Get(0).(func(blockchain.TransactionConfig, quote.PeginQuote) (blockchain.TransactionReceipt, error)); ok {
		return rf(txConfig, peginQuote)
	}
	if rf, ok := ret.Get(0).(func(blockchain.TransactionConfig, quote.PeginQuote) blockchain.TransactionReceipt); ok {
		r0 = rf(txConfig, peginQuote)
	} else {
		r0 = ret.Get(0).(blockchain.TransactionReceipt)
	}

	if rf, ok := ret.Get(1).(func(blockchain.TransactionConfig, quote.PeginQuote) error); ok {
		r1 = rf(txConfig, peginQuote)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_CallForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CallForUser'
type LiquidityBridgeContractMock_CallForUser_Call struct {
	*mock.Call
}

// CallForUser is a helper method to define mock.On call
//   - txConfig blockchain.TransactionConfig
//   - peginQuote quote.PeginQuote
func (_e *LiquidityBridgeContractMock_Expecter) CallForUser(txConfig interface{}, peginQuote interface{}) *LiquidityBridgeContractMock_CallForUser_Call {
	return &LiquidityBridgeContractMock_CallForUser_Call{Call: _e.mock.On("CallForUser", txConfig, peginQuote)}
}

func (_c *LiquidityBridgeContractMock_CallForUser_Call) Run(run func(txConfig blockchain.TransactionConfig, peginQuote quote.PeginQuote)) *LiquidityBridgeContractMock_CallForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(blockchain.TransactionConfig), args[1].(quote.PeginQuote))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_CallForUser_Call) Return(_a0 blockchain.TransactionReceipt, _a1 error) *LiquidityBridgeContractMock_CallForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_CallForUser_Call) RunAndReturn(run func(blockchain.TransactionConfig, quote.PeginQuote) (blockchain.TransactionReceipt, error)) *LiquidityBridgeContractMock_CallForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddress provides a mock function with no fields
func (_m *LiquidityBridgeContractMock) GetAddress() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAddress")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// LiquidityBridgeContractMock_GetAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddress'
type LiquidityBridgeContractMock_GetAddress_Call struct {
	*mock.Call
}

// GetAddress is a helper method to define mock.On call
func (_e *LiquidityBridgeContractMock_Expecter) GetAddress() *LiquidityBridgeContractMock_GetAddress_Call {
	return &LiquidityBridgeContractMock_GetAddress_Call{Call: _e.mock.On("GetAddress")}
}

func (_c *LiquidityBridgeContractMock_GetAddress_Call) Run(run func()) *LiquidityBridgeContractMock_GetAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_GetAddress_Call) Return(_a0 string) *LiquidityBridgeContractMock_GetAddress_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiquidityBridgeContractMock_GetAddress_Call) RunAndReturn(run func() string) *LiquidityBridgeContractMock_GetAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalance provides a mock function with given fields: address
func (_m *LiquidityBridgeContractMock) GetBalance(address string) (*entities.Wei, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetBalance")
	}

	var r0 *entities.Wei
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*entities.Wei, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) *entities.Wei); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.Wei)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_GetBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalance'
type LiquidityBridgeContractMock_GetBalance_Call struct {
	*mock.Call
}

// GetBalance is a helper method to define mock.On call
//   - address string
func (_e *LiquidityBridgeContractMock_Expecter) GetBalance(address interface{}) *LiquidityBridgeContractMock_GetBalance_Call {
	return &LiquidityBridgeContractMock_GetBalance_Call{Call: _e.mock.On("GetBalance", address)}
}

func (_c *LiquidityBridgeContractMock_GetBalance_Call) Run(run func(address string)) *LiquidityBridgeContractMock_GetBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_GetBalance_Call) Return(_a0 *entities.Wei, _a1 error) *LiquidityBridgeContractMock_GetBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_GetBalance_Call) RunAndReturn(run func(string) (*entities.Wei, error)) *LiquidityBridgeContractMock_GetBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollateral provides a mock function with given fields: address
func (_m *LiquidityBridgeContractMock) GetCollateral(address string) (*entities.Wei, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetCollateral")
	}

	var r0 *entities.Wei
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*entities.Wei, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) *entities.Wei); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.Wei)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_GetCollateral_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollateral'
type LiquidityBridgeContractMock_GetCollateral_Call struct {
	*mock.Call
}

// GetCollateral is a helper method to define mock.On call
//   - address string
func (_e *LiquidityBridgeContractMock_Expecter) GetCollateral(address interface{}) *LiquidityBridgeContractMock_GetCollateral_Call {
	return &LiquidityBridgeContractMock_GetCollateral_Call{Call: _e.mock.On("GetCollateral", address)}
}

func (_c *LiquidityBridgeContractMock_GetCollateral_Call) Run(run func(address string)) *LiquidityBridgeContractMock_GetCollateral_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_GetCollateral_Call) Return(_a0 *entities.Wei, _a1 error) *LiquidityBridgeContractMock_GetCollateral_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_GetCollateral_Call) RunAndReturn(run func(string) (*entities.Wei, error)) *LiquidityBridgeContractMock_GetCollateral_Call {
	_c.Call.Return(run)
	return _c
}

// GetDepositEvents provides a mock function with given fields: ctx, fromBlock, toBlock
func (_m *LiquidityBridgeContractMock) GetDepositEvents(ctx context.Context, fromBlock uint64, toBlock *uint64) ([]quote.PegoutDeposit, error) {
	ret := _m.Called(ctx, fromBlock, toBlock)

	if len(ret) == 0 {
		panic("no return value specified for GetDepositEvents")
	}

	var r0 []quote.PegoutDeposit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, *uint64) ([]quote.PegoutDeposit, error)); ok {
		return rf(ctx, fromBlock, toBlock)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, *uint64) []quote.PegoutDeposit); ok {
		r0 = rf(ctx, fromBlock, toBlock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]quote.PegoutDeposit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, *uint64) error); ok {
		r1 = rf(ctx, fromBlock, toBlock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_GetDepositEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDepositEvents'
type LiquidityBridgeContractMock_GetDepositEvents_Call struct {
	*mock.Call
}

// GetDepositEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - fromBlock uint64
//   - toBlock *uint64
func (_e *LiquidityBridgeContractMock_Expecter) GetDepositEvents(ctx interface{}, fromBlock interface{}, toBlock interface{}) *LiquidityBridgeContractMock_GetDepositEvents_Call {
	return &LiquidityBridgeContractMock_GetDepositEvents_Call{Call: _e.mock.On("GetDepositEvents", ctx, fromBlock, toBlock)}
}

func (_c *LiquidityBridgeContractMock_GetDepositEvents_Call) Run(run func(ctx context.Context, fromBlock uint64, toBlock *uint64)) *LiquidityBridgeContractMock_GetDepositEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(*uint64))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_GetDepositEvents_Call) Return(_a0 []quote.PegoutDeposit, _a1 error) *LiquidityBridgeContractMock_GetDepositEvents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_GetDepositEvents_Call) RunAndReturn(run func(context.Context, uint64, *uint64) ([]quote.PegoutDeposit, error)) *LiquidityBridgeContractMock_GetDepositEvents_Call {
	_c.Call.Return(run)
	return _c
}

// GetMinimumCollateral provides a mock function with no fields
func (_m *LiquidityBridgeContractMock) GetMinimumCollateral() (*entities.Wei, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetMinimumCollateral")
	}

	var r0 *entities.Wei
	var r1 error
	if rf, ok := ret.Get(0).(func() (*entities.Wei, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *entities.Wei); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.Wei)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_GetMinimumCollateral_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMinimumCollateral'
type LiquidityBridgeContractMock_GetMinimumCollateral_Call struct {
	*mock.Call
}

// GetMinimumCollateral is a helper method to define mock.On call
func (_e *LiquidityBridgeContractMock_Expecter) GetMinimumCollateral() *LiquidityBridgeContractMock_GetMinimumCollateral_Call {
	return &LiquidityBridgeContractMock_GetMinimumCollateral_Call{Call: _e.mock.On("GetMinimumCollateral")}
}

func (_c *LiquidityBridgeContractMock_GetMinimumCollateral_Call) Run(run func()) *LiquidityBridgeContractMock_GetMinimumCollateral_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_GetMinimumCollateral_Call) Return(_a0 *entities.Wei, _a1 error) *LiquidityBridgeContractMock_GetMinimumCollateral_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_GetMinimumCollateral_Call) RunAndReturn(run func() (*entities.Wei, error)) *LiquidityBridgeContractMock_GetMinimumCollateral_Call {
	_c.Call.Return(run)
	return _c
}

// GetPegoutCollateral provides a mock function with given fields: address
func (_m *LiquidityBridgeContractMock) GetPegoutCollateral(address string) (*entities.Wei, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetPegoutCollateral")
	}

	var r0 *entities.Wei
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*entities.Wei, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) *entities.Wei); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.Wei)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_GetPegoutCollateral_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPegoutCollateral'
type LiquidityBridgeContractMock_GetPegoutCollateral_Call struct {
	*mock.Call
}

// GetPegoutCollateral is a helper method to define mock.On call
//   - address string
func (_e *LiquidityBridgeContractMock_Expecter) GetPegoutCollateral(address interface{}) *LiquidityBridgeContractMock_GetPegoutCollateral_Call {
	return &LiquidityBridgeContractMock_GetPegoutCollateral_Call{Call: _e.mock.On("GetPegoutCollateral", address)}
}

func (_c *LiquidityBridgeContractMock_GetPegoutCollateral_Call) Run(run func(address string)) *LiquidityBridgeContractMock_GetPegoutCollateral_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_GetPegoutCollateral_Call) Return(_a0 *entities.Wei, _a1 error) *LiquidityBridgeContractMock_GetPegoutCollateral_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_GetPegoutCollateral_Call) RunAndReturn(run func(string) (*entities.Wei, error)) *LiquidityBridgeContractMock_GetPegoutCollateral_Call {
	_c.Call.Return(run)
	return _c
}

// GetPenalizedEvents provides a mock function with given fields: ctx, fromBlock, toBlock
func (_m *LiquidityBridgeContractMock) GetPenalizedEvents(ctx context.Context, fromBlock uint64, toBlock *uint64) ([]penalization.PenalizedEvent, error) {
	ret := _m.Called(ctx, fromBlock, toBlock)

	if len(ret) == 0 {
		panic("no return value specified for GetPenalizedEvents")
	}

	var r0 []penalization.PenalizedEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, *uint64) ([]penalization.PenalizedEvent, error)); ok {
		return rf(ctx, fromBlock, toBlock)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, *uint64) []penalization.PenalizedEvent); ok {
		r0 = rf(ctx, fromBlock, toBlock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]penalization.PenalizedEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, *uint64) error); ok {
		r1 = rf(ctx, fromBlock, toBlock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_GetPenalizedEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPenalizedEvents'
type LiquidityBridgeContractMock_GetPenalizedEvents_Call struct {
	*mock.Call
}

// GetPenalizedEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - fromBlock uint64
//   - toBlock *uint64
func (_e *LiquidityBridgeContractMock_Expecter) GetPenalizedEvents(ctx interface{}, fromBlock interface{}, toBlock interface{}) *LiquidityBridgeContractMock_GetPenalizedEvents_Call {
	return &LiquidityBridgeContractMock_GetPenalizedEvents_Call{Call: _e.mock.On("GetPenalizedEvents", ctx, fromBlock, toBlock)}
}

func (_c *LiquidityBridgeContractMock_GetPenalizedEvents_Call) Run(run func(ctx context.Context, fromBlock uint64, toBlock *uint64)) *LiquidityBridgeContractMock_GetPenalizedEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(*uint64))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_GetPenalizedEvents_Call) Return(_a0 []penalization.PenalizedEvent, _a1 error) *LiquidityBridgeContractMock_GetPenalizedEvents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_GetPenalizedEvents_Call) RunAndReturn(run func(context.Context, uint64, *uint64) ([]penalization.PenalizedEvent, error)) *LiquidityBridgeContractMock_GetPenalizedEvents_Call {
	_c.Call.Return(run)
	return _c
}

// GetProvider provides a mock function with given fields: address
func (_m *LiquidityBridgeContractMock) GetProvider(address string) (liquidity_provider.RegisteredLiquidityProvider, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetProvider")
	}

	var r0 liquidity_provider.RegisteredLiquidityProvider
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (liquidity_provider.RegisteredLiquidityProvider, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) liquidity_provider.RegisteredLiquidityProvider); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(liquidity_provider.RegisteredLiquidityProvider)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_GetProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProvider'
type LiquidityBridgeContractMock_GetProvider_Call struct {
	*mock.Call
}

// GetProvider is a helper method to define mock.On call
//   - address string
func (_e *LiquidityBridgeContractMock_Expecter) GetProvider(address interface{}) *LiquidityBridgeContractMock_GetProvider_Call {
	return &LiquidityBridgeContractMock_GetProvider_Call{Call: _e.mock.On("GetProvider", address)}
}

func (_c *LiquidityBridgeContractMock_GetProvider_Call) Run(run func(address string)) *LiquidityBridgeContractMock_GetProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_GetProvider_Call) Return(_a0 liquidity_provider.RegisteredLiquidityProvider, _a1 error) *LiquidityBridgeContractMock_GetProvider_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_GetProvider_Call) RunAndReturn(run func(string) (liquidity_provider.RegisteredLiquidityProvider, error)) *LiquidityBridgeContractMock_GetProvider_Call {
	_c.Call.Return(run)
	return _c
}

// GetProviders provides a mock function with no fields
func (_m *LiquidityBridgeContractMock) GetProviders() ([]liquidity_provider.RegisteredLiquidityProvider, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetProviders")
	}

	var r0 []liquidity_provider.RegisteredLiquidityProvider
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]liquidity_provider.RegisteredLiquidityProvider, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []liquidity_provider.RegisteredLiquidityProvider); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]liquidity_provider.RegisteredLiquidityProvider)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_GetProviders_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProviders'
type LiquidityBridgeContractMock_GetProviders_Call struct {
	*mock.Call
}

// GetProviders is a helper method to define mock.On call
func (_e *LiquidityBridgeContractMock_Expecter) GetProviders() *LiquidityBridgeContractMock_GetProviders_Call {
	return &LiquidityBridgeContractMock_GetProviders_Call{Call: _e.mock.On("GetProviders")}
}

func (_c *LiquidityBridgeContractMock_GetProviders_Call) Run(run func()) *LiquidityBridgeContractMock_GetProviders_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_GetProviders_Call) Return(_a0 []liquidity_provider.RegisteredLiquidityProvider, _a1 error) *LiquidityBridgeContractMock_GetProviders_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_GetProviders_Call) RunAndReturn(run func() ([]liquidity_provider.RegisteredLiquidityProvider, error)) *LiquidityBridgeContractMock_GetProviders_Call {
	_c.Call.Return(run)
	return _c
}

// HashPeginQuote provides a mock function with given fields: peginQuote
func (_m *LiquidityBridgeContractMock) HashPeginQuote(peginQuote quote.PeginQuote) (string, error) {
	ret := _m.Called(peginQuote)

	if len(ret) == 0 {
		panic("no return value specified for HashPeginQuote")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(quote.PeginQuote) (string, error)); ok {
		return rf(peginQuote)
	}
	if rf, ok := ret.Get(0).(func(quote.PeginQuote) string); ok {
		r0 = rf(peginQuote)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(quote.PeginQuote) error); ok {
		r1 = rf(peginQuote)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_HashPeginQuote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashPeginQuote'
type LiquidityBridgeContractMock_HashPeginQuote_Call struct {
	*mock.Call
}

// HashPeginQuote is a helper method to define mock.On call
//   - peginQuote quote.PeginQuote
func (_e *LiquidityBridgeContractMock_Expecter) HashPeginQuote(peginQuote interface{}) *LiquidityBridgeContractMock_HashPeginQuote_Call {
	return &LiquidityBridgeContractMock_HashPeginQuote_Call{Call: _e.mock.On("HashPeginQuote", peginQuote)}
}

func (_c *LiquidityBridgeContractMock_HashPeginQuote_Call) Run(run func(peginQuote quote.PeginQuote)) *LiquidityBridgeContractMock_HashPeginQuote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(quote.PeginQuote))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_HashPeginQuote_Call) Return(_a0 string, _a1 error) *LiquidityBridgeContractMock_HashPeginQuote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_HashPeginQuote_Call) RunAndReturn(run func(quote.PeginQuote) (string, error)) *LiquidityBridgeContractMock_HashPeginQuote_Call {
	_c.Call.Return(run)
	return _c
}

// HashPegoutQuote provides a mock function with given fields: pegoutQuote
func (_m *LiquidityBridgeContractMock) HashPegoutQuote(pegoutQuote quote.PegoutQuote) (string, error) {
	ret := _m.Called(pegoutQuote)

	if len(ret) == 0 {
		panic("no return value specified for HashPegoutQuote")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(quote.PegoutQuote) (string, error)); ok {
		return rf(pegoutQuote)
	}
	if rf, ok := ret.Get(0).(func(quote.PegoutQuote) string); ok {
		r0 = rf(pegoutQuote)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(quote.PegoutQuote) error); ok {
		r1 = rf(pegoutQuote)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_HashPegoutQuote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashPegoutQuote'
type LiquidityBridgeContractMock_HashPegoutQuote_Call struct {
	*mock.Call
}

// HashPegoutQuote is a helper method to define mock.On call
//   - pegoutQuote quote.PegoutQuote
func (_e *LiquidityBridgeContractMock_Expecter) HashPegoutQuote(pegoutQuote interface{}) *LiquidityBridgeContractMock_HashPegoutQuote_Call {
	return &LiquidityBridgeContractMock_HashPegoutQuote_Call{Call: _e.mock.On("HashPegoutQuote", pegoutQuote)}
}

func (_c *LiquidityBridgeContractMock_HashPegoutQuote_Call) Run(run func(pegoutQuote quote.PegoutQuote)) *LiquidityBridgeContractMock_HashPegoutQuote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(quote.PegoutQuote))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_HashPegoutQuote_Call) Return(_a0 string, _a1 error) *LiquidityBridgeContractMock_HashPegoutQuote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_HashPegoutQuote_Call) RunAndReturn(run func(quote.PegoutQuote) (string, error)) *LiquidityBridgeContractMock_HashPegoutQuote_Call {
	_c.Call.Return(run)
	return _c
}

// IsOperationalPegin provides a mock function with given fields: address
func (_m *LiquidityBridgeContractMock) IsOperationalPegin(address string) (bool, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for IsOperationalPegin")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_IsOperationalPegin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsOperationalPegin'
type LiquidityBridgeContractMock_IsOperationalPegin_Call struct {
	*mock.Call
}

// IsOperationalPegin is a helper method to define mock.On call
//   - address string
func (_e *LiquidityBridgeContractMock_Expecter) IsOperationalPegin(address interface{}) *LiquidityBridgeContractMock_IsOperationalPegin_Call {
	return &LiquidityBridgeContractMock_IsOperationalPegin_Call{Call: _e.mock.On("IsOperationalPegin", address)}
}

func (_c *LiquidityBridgeContractMock_IsOperationalPegin_Call) Run(run func(address string)) *LiquidityBridgeContractMock_IsOperationalPegin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_IsOperationalPegin_Call) Return(_a0 bool, _a1 error) *LiquidityBridgeContractMock_IsOperationalPegin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_IsOperationalPegin_Call) RunAndReturn(run func(string) (bool, error)) *LiquidityBridgeContractMock_IsOperationalPegin_Call {
	_c.Call.Return(run)
	return _c
}

// IsOperationalPegout provides a mock function with given fields: address
func (_m *LiquidityBridgeContractMock) IsOperationalPegout(address string) (bool, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for IsOperationalPegout")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_IsOperationalPegout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsOperationalPegout'
type LiquidityBridgeContractMock_IsOperationalPegout_Call struct {
	*mock.Call
}

// IsOperationalPegout is a helper method to define mock.On call
//   - address string
func (_e *LiquidityBridgeContractMock_Expecter) IsOperationalPegout(address interface{}) *LiquidityBridgeContractMock_IsOperationalPegout_Call {
	return &LiquidityBridgeContractMock_IsOperationalPegout_Call{Call: _e.mock.On("IsOperationalPegout", address)}
}

func (_c *LiquidityBridgeContractMock_IsOperationalPegout_Call) Run(run func(address string)) *LiquidityBridgeContractMock_IsOperationalPegout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_IsOperationalPegout_Call) Return(_a0 bool, _a1 error) *LiquidityBridgeContractMock_IsOperationalPegout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_IsOperationalPegout_Call) RunAndReturn(run func(string) (bool, error)) *LiquidityBridgeContractMock_IsOperationalPegout_Call {
	_c.Call.Return(run)
	return _c
}

// IsPegOutQuoteCompleted provides a mock function with given fields: quoteHash
func (_m *LiquidityBridgeContractMock) IsPegOutQuoteCompleted(quoteHash string) (bool, error) {
	ret := _m.Called(quoteHash)

	if len(ret) == 0 {
		panic("no return value specified for IsPegOutQuoteCompleted")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(quoteHash)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(quoteHash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(quoteHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsPegOutQuoteCompleted'
type LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call struct {
	*mock.Call
}

// IsPegOutQuoteCompleted is a helper method to define mock.On call
//   - quoteHash string
func (_e *LiquidityBridgeContractMock_Expecter) IsPegOutQuoteCompleted(quoteHash interface{}) *LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call {
	return &LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call{Call: _e.mock.On("IsPegOutQuoteCompleted", quoteHash)}
}

func (_c *LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call) Run(run func(quoteHash string)) *LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call) Return(_a0 bool, _a1 error) *LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call) RunAndReturn(run func(string) (bool, error)) *LiquidityBridgeContractMock_IsPegOutQuoteCompleted_Call {
	_c.Call.Return(run)
	return _c
}

// ProviderResign provides a mock function with no fields
func (_m *LiquidityBridgeContractMock) ProviderResign() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ProviderResign")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiquidityBridgeContractMock_ProviderResign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProviderResign'
type LiquidityBridgeContractMock_ProviderResign_Call struct {
	*mock.Call
}

// ProviderResign is a helper method to define mock.On call
func (_e *LiquidityBridgeContractMock_Expecter) ProviderResign() *LiquidityBridgeContractMock_ProviderResign_Call {
	return &LiquidityBridgeContractMock_ProviderResign_Call{Call: _e.mock.On("ProviderResign")}
}

func (_c *LiquidityBridgeContractMock_ProviderResign_Call) Run(run func()) *LiquidityBridgeContractMock_ProviderResign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_ProviderResign_Call) Return(_a0 error) *LiquidityBridgeContractMock_ProviderResign_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiquidityBridgeContractMock_ProviderResign_Call) RunAndReturn(run func() error) *LiquidityBridgeContractMock_ProviderResign_Call {
	_c.Call.Return(run)
	return _c
}

// RefundPegout provides a mock function with given fields: txConfig, params
func (_m *LiquidityBridgeContractMock) RefundPegout(txConfig blockchain.TransactionConfig, params blockchain.RefundPegoutParams) (string, error) {
	ret := _m.Called(txConfig, params)

	if len(ret) == 0 {
		panic("no return value specified for RefundPegout")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(blockchain.TransactionConfig, blockchain.RefundPegoutParams) (string, error)); ok {
		return rf(txConfig, params)
	}
	if rf, ok := ret.Get(0).(func(blockchain.TransactionConfig, blockchain.RefundPegoutParams) string); ok {
		r0 = rf(txConfig, params)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(blockchain.TransactionConfig, blockchain.RefundPegoutParams) error); ok {
		r1 = rf(txConfig, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_RefundPegout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefundPegout'
type LiquidityBridgeContractMock_RefundPegout_Call struct {
	*mock.Call
}

// RefundPegout is a helper method to define mock.On call
//   - txConfig blockchain.TransactionConfig
//   - params blockchain.RefundPegoutParams
func (_e *LiquidityBridgeContractMock_Expecter) RefundPegout(txConfig interface{}, params interface{}) *LiquidityBridgeContractMock_RefundPegout_Call {
	return &LiquidityBridgeContractMock_RefundPegout_Call{Call: _e.mock.On("RefundPegout", txConfig, params)}
}

func (_c *LiquidityBridgeContractMock_RefundPegout_Call) Run(run func(txConfig blockchain.TransactionConfig, params blockchain.RefundPegoutParams)) *LiquidityBridgeContractMock_RefundPegout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(blockchain.TransactionConfig), args[1].(blockchain.RefundPegoutParams))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_RefundPegout_Call) Return(_a0 string, _a1 error) *LiquidityBridgeContractMock_RefundPegout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_RefundPegout_Call) RunAndReturn(run func(blockchain.TransactionConfig, blockchain.RefundPegoutParams) (string, error)) *LiquidityBridgeContractMock_RefundPegout_Call {
	_c.Call.Return(run)
	return _c
}

// RefundUserPegOut provides a mock function with given fields: quoteHash
func (_m *LiquidityBridgeContractMock) RefundUserPegOut(quoteHash string) (string, error) {
	ret := _m.Called(quoteHash)

	if len(ret) == 0 {
		panic("no return value specified for RefundUserPegOut")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(quoteHash)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(quoteHash)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(quoteHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_RefundUserPegOut_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefundUserPegOut'
type LiquidityBridgeContractMock_RefundUserPegOut_Call struct {
	*mock.Call
}

// RefundUserPegOut is a helper method to define mock.On call
//   - quoteHash string
func (_e *LiquidityBridgeContractMock_Expecter) RefundUserPegOut(quoteHash interface{}) *LiquidityBridgeContractMock_RefundUserPegOut_Call {
	return &LiquidityBridgeContractMock_RefundUserPegOut_Call{Call: _e.mock.On("RefundUserPegOut", quoteHash)}
}

func (_c *LiquidityBridgeContractMock_RefundUserPegOut_Call) Run(run func(quoteHash string)) *LiquidityBridgeContractMock_RefundUserPegOut_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_RefundUserPegOut_Call) Return(_a0 string, _a1 error) *LiquidityBridgeContractMock_RefundUserPegOut_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_RefundUserPegOut_Call) RunAndReturn(run func(string) (string, error)) *LiquidityBridgeContractMock_RefundUserPegOut_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterPegin provides a mock function with given fields: params
func (_m *LiquidityBridgeContractMock) RegisterPegin(params blockchain.RegisterPeginParams) (blockchain.TransactionReceipt, error) {
	ret := _m.Called(params)

	if len(ret) == 0 {
		panic("no return value specified for RegisterPegin")
	}

	var r0 blockchain.TransactionReceipt
	var r1 error
	if rf, ok := ret.Get(0).(func(blockchain.RegisterPeginParams) (blockchain.TransactionReceipt, error)); ok {
		return rf(params)
	}
	if rf, ok := ret.Get(0).(func(blockchain.RegisterPeginParams) blockchain.TransactionReceipt); ok {
		r0 = rf(params)
	} else {
		r0 = ret.Get(0).(blockchain.TransactionReceipt)
	}

	if rf, ok := ret.Get(1).(func(blockchain.RegisterPeginParams) error); ok {
		r1 = rf(params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_RegisterPegin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterPegin'
type LiquidityBridgeContractMock_RegisterPegin_Call struct {
	*mock.Call
}

// RegisterPegin is a helper method to define mock.On call
//   - params blockchain.RegisterPeginParams
func (_e *LiquidityBridgeContractMock_Expecter) RegisterPegin(params interface{}) *LiquidityBridgeContractMock_RegisterPegin_Call {
	return &LiquidityBridgeContractMock_RegisterPegin_Call{Call: _e.mock.On("RegisterPegin", params)}
}

func (_c *LiquidityBridgeContractMock_RegisterPegin_Call) Run(run func(params blockchain.RegisterPeginParams)) *LiquidityBridgeContractMock_RegisterPegin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(blockchain.RegisterPeginParams))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_RegisterPegin_Call) Return(_a0 blockchain.TransactionReceipt, _a1 error) *LiquidityBridgeContractMock_RegisterPegin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_RegisterPegin_Call) RunAndReturn(run func(blockchain.RegisterPeginParams) (blockchain.TransactionReceipt, error)) *LiquidityBridgeContractMock_RegisterPegin_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterProvider provides a mock function with given fields: txConfig, params
func (_m *LiquidityBridgeContractMock) RegisterProvider(txConfig blockchain.TransactionConfig, params blockchain.ProviderRegistrationParams) (int64, error) {
	ret := _m.Called(txConfig, params)

	if len(ret) == 0 {
		panic("no return value specified for RegisterProvider")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(blockchain.TransactionConfig, blockchain.ProviderRegistrationParams) (int64, error)); ok {
		return rf(txConfig, params)
	}
	if rf, ok := ret.Get(0).(func(blockchain.TransactionConfig, blockchain.ProviderRegistrationParams) int64); ok {
		r0 = rf(txConfig, params)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(blockchain.TransactionConfig, blockchain.ProviderRegistrationParams) error); ok {
		r1 = rf(txConfig, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_RegisterProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterProvider'
type LiquidityBridgeContractMock_RegisterProvider_Call struct {
	*mock.Call
}

// RegisterProvider is a helper method to define mock.On call
//   - txConfig blockchain.TransactionConfig
//   - params blockchain.ProviderRegistrationParams
func (_e *LiquidityBridgeContractMock_Expecter) RegisterProvider(txConfig interface{}, params interface{}) *LiquidityBridgeContractMock_RegisterProvider_Call {
	return &LiquidityBridgeContractMock_RegisterProvider_Call{Call: _e.mock.On("RegisterProvider", txConfig, params)}
}

func (_c *LiquidityBridgeContractMock_RegisterProvider_Call) Run(run func(txConfig blockchain.TransactionConfig, params blockchain.ProviderRegistrationParams)) *LiquidityBridgeContractMock_RegisterProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(blockchain.TransactionConfig), args[1].(blockchain.ProviderRegistrationParams))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_RegisterProvider_Call) Return(_a0 int64, _a1 error) *LiquidityBridgeContractMock_RegisterProvider_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_RegisterProvider_Call) RunAndReturn(run func(blockchain.TransactionConfig, blockchain.ProviderRegistrationParams) (int64, error)) *LiquidityBridgeContractMock_RegisterProvider_Call {
	_c.Call.Return(run)
	return _c
}

// SetProviderStatus provides a mock function with given fields: id, newStatus
func (_m *LiquidityBridgeContractMock) SetProviderStatus(id uint64, newStatus bool) error {
	ret := _m.Called(id, newStatus)

	if len(ret) == 0 {
		panic("no return value specified for SetProviderStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, bool) error); ok {
		r0 = rf(id, newStatus)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiquidityBridgeContractMock_SetProviderStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetProviderStatus'
type LiquidityBridgeContractMock_SetProviderStatus_Call struct {
	*mock.Call
}

// SetProviderStatus is a helper method to define mock.On call
//   - id uint64
//   - newStatus bool
func (_e *LiquidityBridgeContractMock_Expecter) SetProviderStatus(id interface{}, newStatus interface{}) *LiquidityBridgeContractMock_SetProviderStatus_Call {
	return &LiquidityBridgeContractMock_SetProviderStatus_Call{Call: _e.mock.On("SetProviderStatus", id, newStatus)}
}

func (_c *LiquidityBridgeContractMock_SetProviderStatus_Call) Run(run func(id uint64, newStatus bool)) *LiquidityBridgeContractMock_SetProviderStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(bool))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_SetProviderStatus_Call) Return(_a0 error) *LiquidityBridgeContractMock_SetProviderStatus_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiquidityBridgeContractMock_SetProviderStatus_Call) RunAndReturn(run func(uint64, bool) error) *LiquidityBridgeContractMock_SetProviderStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProvider provides a mock function with given fields: name, url
func (_m *LiquidityBridgeContractMock) UpdateProvider(name string, url string) (string, error) {
	ret := _m.Called(name, url)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProvider")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return rf(name, url)
	}
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(name, url)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(name, url)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidityBridgeContractMock_UpdateProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProvider'
type LiquidityBridgeContractMock_UpdateProvider_Call struct {
	*mock.Call
}

// UpdateProvider is a helper method to define mock.On call
//   - name string
//   - url string
func (_e *LiquidityBridgeContractMock_Expecter) UpdateProvider(name interface{}, url interface{}) *LiquidityBridgeContractMock_UpdateProvider_Call {
	return &LiquidityBridgeContractMock_UpdateProvider_Call{Call: _e.mock.On("UpdateProvider", name, url)}
}

func (_c *LiquidityBridgeContractMock_UpdateProvider_Call) Run(run func(name string, url string)) *LiquidityBridgeContractMock_UpdateProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_UpdateProvider_Call) Return(_a0 string, _a1 error) *LiquidityBridgeContractMock_UpdateProvider_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LiquidityBridgeContractMock_UpdateProvider_Call) RunAndReturn(run func(string, string) (string, error)) *LiquidityBridgeContractMock_UpdateProvider_Call {
	_c.Call.Return(run)
	return _c
}

// WithdrawCollateral provides a mock function with no fields
func (_m *LiquidityBridgeContractMock) WithdrawCollateral() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for WithdrawCollateral")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LiquidityBridgeContractMock_WithdrawCollateral_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithdrawCollateral'
type LiquidityBridgeContractMock_WithdrawCollateral_Call struct {
	*mock.Call
}

// WithdrawCollateral is a helper method to define mock.On call
func (_e *LiquidityBridgeContractMock_Expecter) WithdrawCollateral() *LiquidityBridgeContractMock_WithdrawCollateral_Call {
	return &LiquidityBridgeContractMock_WithdrawCollateral_Call{Call: _e.mock.On("WithdrawCollateral")}
}

func (_c *LiquidityBridgeContractMock_WithdrawCollateral_Call) Run(run func()) *LiquidityBridgeContractMock_WithdrawCollateral_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LiquidityBridgeContractMock_WithdrawCollateral_Call) Return(_a0 error) *LiquidityBridgeContractMock_WithdrawCollateral_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LiquidityBridgeContractMock_WithdrawCollateral_Call) RunAndReturn(run func() error) *LiquidityBridgeContractMock_WithdrawCollateral_Call {
	_c.Call.Return(run)
	return _c
}

// NewLiquidityBridgeContractMock creates a new instance of LiquidityBridgeContractMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLiquidityBridgeContractMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *LiquidityBridgeContractMock {
	mock := &LiquidityBridgeContractMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
